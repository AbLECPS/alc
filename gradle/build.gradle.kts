/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds
 */
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import groovy.json.StringEscapeUtils

import java.time.LocalDateTime
import java.time.Instant
import java.util.TimeZone

import java.time.format.DateTimeFormatter


repositories {
    jcenter()
}


val dateTimeFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-DD'T'HH:mm:ss.nnn'Z'")
val workflowDirOption = "__workflow_dir__"

val alcPluginName = "ALCModelUpdater"
val executionPluginName = "ExecuteExpt"


//
// KEYS IN JOB STANZAS FOR CHECKING JOB RESULTS
//
val checkScriptPathConfigKey = "check_script_path"
val maxIterationsConfigKey = "max_iterations"
val restartAtJobConfigKey = "restart_at_job"
val jobNameConfigKey = "job_name"
val prevJobsConfigKey = "prev_jobs"


if (gradle.startParameter.taskNames.size > 1) {
    throw GradleException("ERROR:  This build script can only be run with a single task")
}
val primaryTaskName = if (gradle.startParameter.taskNames.size > 0) {
    gradle.startParameter.taskNames[0] as String
} else {
    "NONE"
}

fun poJobSort(jobInfoMap: Map<String, Map<*,*>>, orderInfo: Map<String, List<*>>): List<Map<*,*>> {

    val jobInfoList = jobInfoMap.map { Pair(it.key, it.value)}.toMutableList()

    var start = 0
    val size = jobInfoList.size

    while(start < size) {
        val jobName = jobInfoList[start].first
        val prevJobSet = orderInfo[jobName]?.toMutableSet()
        if (prevJobSet != null) {
            var swapped = false
            var ix = start + 1
            while (ix < size && prevJobSet.isNotEmpty()) {
                val otherJobName = jobInfoList[ix].first
                if (prevJobSet.contains(otherJobName)) {
                    prevJobSet.remove(otherJobName)
                    jobInfoList[start] = jobInfoList[ix].also { jobInfoList[ix] = jobInfoList[start] }
                    start = ix
                    swapped = true
                }
                ix += 1
            }
            if (!swapped) {
                start += 1
            }
        }
    }

    return jobInfoList.map { it.second }
}

fun updateOrderInfo(item: Map<*,*>, orderInfo: MutableMap<String, List<*>>) {
    if (item.containsKey(prevJobsConfigKey)) {
        when(val prevJobsList = item[prevJobsConfigKey]) {
            is List<*> -> orderInfo[item[jobNameConfigKey] as String] = prevJobsList
            else -> throw IllegalArgumentException("\"job_name\" of job spec must be list of other job names")
        }
    } else {
        orderInfo[item[jobNameConfigKey] as String] = listOf<String>()
    }
}

fun getJobInfo(jobList: List<*>): List<Map<*,*>> {

    val jobInfoMap = mutableMapOf<String, Map<*,*>>()
    val orderInfo = mutableMapOf<String, List<*>>()

    for(item in jobList) {
        when(item) {
            is Map<*,*> -> {
                if (item.containsKey(jobNameConfigKey)) {
                    val key = item[jobNameConfigKey] as String
                    jobInfoMap[key] = item
                    orderInfo[key] = if (item.containsKey(prevJobsConfigKey)) {
                        item[prevJobsConfigKey] as List<*>
                    } else {
                        listOf()
                    }
                    updateOrderInfo(item, orderInfo)
                } else {
                    throw IllegalArgumentException("Every jobs spec must have a \"job_name\"")
                }
            }
            else -> throw IllegalArgumentException("Objects in \"jobs\" must be maps")
        }
    }

    return poJobSort(jobInfoMap, orderInfo)
}


val topLevelParameterList = listOf(
        "projectName",
        "genericActiveNode",
        "buildRoot",
        "owner",
        "statusPath"
)

fun processConfig(configFileJson: Map<*,*>) {

    for(parameterName in topLevelParameterList) {
        when {
            configFileJson.containsKey(parameterName) -> {
                ext[parameterName] = configFileJson[parameterName]
            }
            else -> {
                throw IllegalArgumentException("config file must specify $parameterName")
            }
        }
    }

    if (configFileJson.containsKey("jobs")) {
        when(val jobsJson = configFileJson["jobs"]) {
            is List<*> -> ext["jobs"] = getJobInfo(jobsJson)
            else -> throw IllegalArgumentException("\"jobs\" element of config file must be a list of maps")
        }
    } else {
        throw IllegalArgumentException("config file must specify jobs list")
    }

}

val configFileOptionString = "config_file"


fun getConfig() {

    if (!ext.has(configFileOptionString)) {
        val warningMessage = "WARNING:  NO $configFileOptionString SPECIFIED.  USING TEST $configFileOptionString"
        logger.warn(warningMessage)
        ext[configFileOptionString] = "$projectDir/src/test/resources/gradle-input.json"
    }

    when (val configFileJson = JsonSlurper().parse(File(ext.properties[configFileOptionString] as String))) {
        is Map<*, *> -> processConfig(configFileJson)
        else -> throw IllegalArgumentException("config file root object must be a map")
    }
}

getConfig()


val projectName: String by ext
val genericActiveNode: String by ext

val webgmeHost = "localhost"
val webgmePort = 8888
val webgmeUrl = "http://$webgmeHost:$webgmePort"

val webgmeHome = "/alc/webgme"
val webgmeHomeDir = File(webgmeHome)

val username = "alc"
val password = "alc"
val userarg = "$username:$password"

val namespace = "ALCMeta"

val buildRoot: String by ext

val buildRootDir = File(buildRoot)
buildRootDir.mkdirs()

val owner: String by ext
val statusPath: String by ext


val fileDir = File(buildRootDir,"files")
fileDir.mkdirs()


val runDir = File(buildRootDir, "run")
runDir.mkdirs()


val workflowTaskName = "workflow"


val iterationDirOptionString = "iteration_directory"
val prevIterationDirOptionString = "prev_iteration_directory"

val iterationDir = when {
    ext.has(iterationDirOptionString) -> File(ext[iterationDirOptionString] as String)
    primaryTaskName == workflowTaskName -> {
        throw GradleException("Task \"$primaryTaskName\" must have \"$iterationDirOptionString\" on command line.")
    }
    else -> runDir // BOGUS VALUE SO iterationDir HAS "File" TYPE
}

val prevIterationDir = if (ext.has(prevIterationDirOptionString)) {
    File(ext[prevIterationDirOptionString] as String)
} else {
    null
}


fun getUpdatesFile(iterationDir: File): File {
    return File(iterationDir, "updates.json")
}

fun getCheckFile(iterationDir: File): File {
    return File(iterationDir, "check.json")
}


val configDir = File(buildRootDir, "config")
configDir.mkdirs()

val configFile = File(configDir, "config.json")
val loopFile = File(configDir, "loop.json")


fun writeLoopFile() {
    loopFile.writeText("")
}

fun writeLoopFile(updateDir: File) {
    loopFile.writeText(convertToJson(updateDir.absolutePath))
}


writeLoopFile()


//
// WORKFLOW
//
val jobInfoKey = "job_info"
val controlInfoKey = "control_info"
val stateInfoKey = "state_info"

val mainIterationKey = "main_iteration"
val jobIterationKey = "job_iteration"
val iterationJobNameKey = "iteration_job_name"


val checkMap = mapOf<String, MutableMap<String, Any>>(
        jobInfoKey to mutableMapOf(),
        controlInfoKey to mutableMapOf(),
        stateInfoKey to mutableMapOf()
)

val jobInfoMap = checkMap[jobInfoKey] as MutableMap<String, MutableMap<String, List<*>>>
val controlInfoMap = checkMap[controlInfoKey] as MutableMap<String, Any>
val stateInfoMap = checkMap[stateInfoKey] as MutableMap<String, Any>

val prevCheckMap = if (prevIterationDir == null) {
    mapOf(
            jobInfoKey to mapOf(),
            controlInfoKey to mapOf(),
            stateInfoKey to mapOf()
    )
} else {
    val checkFile = getCheckFile(prevIterationDir)
    JsonSlurper().parse(checkFile) as Map<String, Map<String, Any>>
}

val prevJobInfoMap = prevCheckMap[jobInfoKey] as Map<String, Map<String, List<*>>>


val updateMap = if (prevIterationDir == null) {
    mapOf(
            jobInfoKey to mutableMapOf(),
            controlInfoKey to mutableMapOf(),
            stateInfoKey to mutableMapOf()
    )
} else {
    val updateFile = getUpdatesFile(prevIterationDir)
    JsonSlurper().parse(updateFile) as Map<String,MutableMap<String, Any>>
}

val updateJobInfoMap = updateMap[jobInfoKey] as Map<String, Any>
val updateControlInfoMap = updateMap[controlInfoKey] as Map<String, Any>
val updateStateInfoMap = updateMap[stateInfoKey] as Map<String, Any>

stateInfoMap.putAll(updateStateInfoMap)


//
// SPECIAL KEYS ADDED TO updates.json FILE FOR A JOB
//
val mainIteration = (updateControlInfoMap[mainIterationKey] ?: 0) as Int
val jobIteration = (updateControlInfoMap[jobIterationKey] ?: 0) as Int
val iterationJobName = (updateControlInfoMap[iterationJobNameKey] ?: "") as String

val restartAtJobUpdateKey = "restart_at_job"
val restartAtJobUpdate = (updateControlInfoMap[restartAtJobUpdateKey] ?: "") as String

val activityParameterValueUpdateKey = "activities"
val defaultParameterValuesUpdateKey = "default"



val jobs: List<*> by ext
val dependencies = mutableMapOf<String, List<Task>>()
val resultTasks = mutableMapOf<String, List<Task>>()


fun getJobMap(jobList: List<*>): Map<String, Map<*,*>> {
    val jobOrderMap = mutableMapOf<String, Map<*,*>>()
    for(job in jobList) {
        job as Map<*, *>
        val jobName = job[jobNameConfigKey] as String
        jobOrderMap[jobName] = job
    }
    return jobOrderMap.toMap()
}

fun getSkipSet(restartAtJob: String, jobMap: Map<String, Map<*,*>>): Set<*> {
    val baseSet = (jobMap[restartAtJob]?.get(prevJobsConfigKey) as List<*>?)?.toMutableSet() ?: mutableSetOf()
    baseSet.addAll(
            baseSet.stream()
                    .flatMap { getSkipSet(it as String, jobMap).stream() }
                    .collect(java.util.stream.Collectors.toSet())
    )
    return baseSet.toSet()
}

//
// SET OF NAMES OF JOBS THAT SHOULD BE SKIPPED FOR THIS EXECUTION
//
val skipJobSet = getSkipSet(restartAtJobUpdate, getJobMap(jobs))


val currentTime = System.currentTimeMillis()

for (job in jobs) {
    performJob(job as Map<*, *>)
}

if (jobs.isNotEmpty()) {
    val lastJobName = getJobName(jobs[jobs.lastIndex] as Map<*, *>)

    val configFunction = { task: Task ->

        task.dependsOn(dependencies[lastJobName])

        val statusMap = getUpToDateJson()
        statusMap["jobName"] = workflowTaskName
        statusMap["taskName"] = workflowTaskName

        task.doFirst {
            val statusJson = StringEscapeUtils.escapeJavaScript(JsonOutput.toJson(statusMap))
            val inputFile: File by task.extra
            inputFile.writeText(setStatusMessage(statusJson))
        }

        task.doLast {
            val checkFile = getCheckFile(iterationDir)

            controlInfoMap[mainIterationKey] = mainIteration
            controlInfoMap[jobIterationKey] = jobIteration
            controlInfoMap[iterationJobNameKey] = workflowTaskName

            checkFile.writeText(convertToJson(checkMap))

            val updatesFile = getUpdatesFile(iterationDir)

            val updates = mutableMapOf(
                    jobInfoKey to mapOf<String, Any>(),
                    controlInfoKey to controlInfoMap,
                    stateInfoKey to stateInfoMap
            )
            updatesFile.writeText(convertToJson(updates))
        }

        Unit
    }

    registerExecTask(
            workflowTaskName,
            primary_input_file = false,
            has_output_file = false,
            up_to_date = false,
            configFunction = configFunction
    )

}


fun setSkipJob(task: Task, jobName: String, skipJob: Boolean) {

    if (skipJob) {
        task.onlyIf {
            println(
                    "Skipping task \"${task.name}\" for job \"$jobName\" as processing" +
                            " is to start with job \"$restartAtJobUpdate\""
            )
            false
        }
    }
}

fun setSkipJob(taskPair: Pair<Exec, Exec>, jobName: String, skipJob: Boolean) {
    setSkipJob(taskPair.first, jobName, skipJob)
    setSkipJob(taskPair.second, jobName, skipJob)
}

fun convertToJson(data: Any): String {
    return JsonOutput.prettyPrint(JsonOutput.toJson(data))
}



fun performJob(job: Map<*, *>) {

    val jobName = getJobName(job)
    val localCheckScriptPath = (job[checkScriptPathConfigKey] ?: "") as String
    val maxIterations = (job[maxIterationsConfigKey] ?: 1) as Int
    val restartAtJob = job[restartAtJobConfigKey] as String?

    val skipJob = skipJobSet.contains(jobName)

    if (skipJob && prevJobInfoMap.containsKey(jobName)) {
        jobInfoMap[jobName] = (prevJobInfoMap[jobName] as Map<String, List<*>>).toMutableMap()
    }

    var startJobBanner = true

    val prevTaskList = if (job.containsKey(prevJobsConfigKey)) {
        val prevJobNameList = job[prevJobsConfigKey] as List<*>
        prevJobNameList.flatMap { dependencies[it] as List<Task> }.toMutableList()
    } else {
        mutableListOf()
    }


    //
    // PROCESS INITS
    //
    val initTaskList = mutableListOf<Task>()

    if (job.containsKey("inits")) {
        val inits = job["inits"] as List<*>

        for(ix in inits.indices) {
            val initJob = inits[ix]

            val taskName = "inits-$ix-$jobName"
            val configFunction = { task: Task ->
                val inputFile: File by task.extra
                inputFile.writeText(convertToJson(mapOf("1" to initJob)))
            }

            val initsTaskPair = registerInspectedExecTask(
                    taskName,
                    jobName,
                    has_output_file = false,
                    configFunction = configFunction,
                    prevTaskList = prevTaskList.toList()
            )

            if (startJobBanner) {
                initsTaskPair.first.doFirst {
                    println("-------------------- Starting job \"$jobName\" --------------------")
                }
                startJobBanner = false
            }

            setSkipJob(initsTaskPair, jobName, skipJob)

            initTaskList.add(initsTaskPair.second)
        }
    }

    prevTaskList.addAll(initTaskList)


    //
    // PROCESS INPUTS
    //
    val inputTaskList = mutableListOf<Task>()

    if (job.containsKey("inputs")) {
        val inputs = job["inputs"] as List<*>

        for(ix in inputs.indices) {
            val inputJob = (inputs[ix] as Map<*,*>).toMutableMap()

            val specTaskName = inputJob["task_name"] as String
            val taskName = "inputs-$ix-$jobName-$specTaskName"

            val previousJobName = inputJob["prev_job"] as String

            val configFunction = { task: Exec ->
                val inputFile: File by task.extra
                val depFiles = (resultTasks[previousJobName] as List<Task>)
                        .map { val outputPathFile: File by it.extra; outputPathFile }
                task.inputs.files(depFiles)
                task.doFirst {
                    val pathMap = depFiles.map { JsonSlurper().parse(it) as Map<*,*> }
                            .fold(mutableMapOf<String, String>()) { mutableMap, inputMap ->
                                mutableMap.putAll(inputMap.map {it.key as String to it.value as String}.toMap())
                                mutableMap
                            }
                    val pathList = if (job.getOrDefault("use_all", false) as Boolean) {
                        pathMap.map {it.value}
                    } else {
                        pathMap.filter {it.key.contains(currentTime.toString())}.map {it.value}
                    }
                    inputJob["src"] = pathList
                    inputFile.writeText(convertToJson(mapOf("1" to inputJob)))
                }
                Unit
            }

            val inputsTaskPair = registerInspectedExecTask(
                    taskName,
                    jobName,
                    primary_input_file = false,
                    has_output_file = false,
                    configFunction = configFunction,
                    prevTaskList = prevTaskList.toList()
            )

            setSkipJob(inputsTaskPair, jobName, skipJob)

            inputTaskList.add(inputsTaskPair.second)
        }
    }

    prevTaskList.addAll(inputTaskList)


    //
    // PROCESS ACTIVITIES
    //
    if (job.containsKey("activities_map")) {
        val activitiesMap = job["activities_map"] as Map<*, *>

        val activitiesTaskPairList = mutableListOf<Pair<Exec, Exec>>()

        for((k,v) in activitiesMap) {
            k as String
            v as String


            //
            // ACTIVITY TASK
            //
            val activityTaskName = "activity-$k-$jobName"
            val execName = "$activityTaskName-$currentTime"
            val activityTaskPair = registerExperimentTask(
                    jobName,
                    k,
                    v,
                    execName,
                    activityTaskName,
                    prevTaskList.toList()
            )

            setSkipJob(activityTaskPair, jobName, skipJob)


            //
            // RESULT TASK
            //
            val configFunction = { task: Exec ->
                val inputFile: File by task.extra
                val outputFile: File by task.extra

                inputFile.writeText(getDgResultInput(v, outputFile, activityTaskName))

                val outputDir: File by task.extra

                val outputPathFileName = "outputPath.json"
                val outputPathFile by task.extra(File(outputDir, outputPathFileName))

                task.outputs.file(outputPathFile)
                task.doLast {
                    val json = JsonSlurper().parse(outputFile) as Map<*, *>
                    val resultsList = json["Test"] as MutableList<*>
                    resultsList.sortBy { (it as Map<*, *>).get("time") as Long }

                    val pathMap = mutableMapOf<String, String>()
                    for (result in resultsList) {
                        val resultMap = result as Map<*, *>
                        pathMap[resultMap["name"] as String] = resultMap["path"] as String
                    }
                    outputPathFile.writeText(JsonOutput.toJson(pathMap))

                    jobInfoMap.compute(jobName) { _, value: Any? ->
                        if (value == null) {
                            mutableMapOf(k to resultsList)
                        } else {
                            value as MutableMap<String, List<*>>
                            value[k] = resultsList
                            value
                        }
                    }
                }

                Unit
            }

            val resultsTaskName = "results-$k-$jobName"
            val resultsTaskPair = registerInspectedExecTask(
                    resultsTaskName,
                    jobName,
                    has_output_file = false,
                    up_to_date = activityTaskPair.first.state.upToDate,
                    configFunction = configFunction,
                    prevTaskList = listOf(activityTaskPair.second)
            )

            setSkipJob(resultsTaskPair, jobName, skipJob)

            activitiesTaskPairList.add(resultsTaskPair)


            //
            // CHECK IF LATEST OUTPUTS SHOULD BE USED AS INPUTS
            //
            if (job.getOrDefault("use_latest", false) as Boolean) {

                val resultTask = resultsTaskPair.first
                val outputPathFile: File by resultTask.extra

                if (outputPathFile.exists()) {
                    val taskName = "use-latest-$k-$jobName"

                    val initialNodePathMap = JsonSlurper().parse(outputPathFile) as Map<*,*>

                    val useLatestConfigFunction = { task: Task ->
                        val inputFile: File by task.extra
                        inputFile.writeText(getTrainingNetInput(listOf(v), initialNodePathMap.map { it.value as String }))
                    }

                    val useLatestTaskPair = registerInspectedExecTask(
                            taskName,
                            jobName,
                            has_output_file = false,
                            configFunction = useLatestConfigFunction,
                            prevTaskList = prevTaskList.toList()
                    )

                    activityTaskPair.first.dependsOn(useLatestTaskPair.second)

                    setSkipJob(useLatestTaskPair, jobName, skipJob)
                }
            }
        }

        val evaluateTaskPair = registerEvaluateTask(
                jobName, localCheckScriptPath, maxIterations, restartAtJob, activitiesTaskPairList.map {it.second}
        )

        setSkipJob(evaluateTaskPair, jobName, skipJob)

        dependencies[jobName] = listOf(evaluateTaskPair.second)
        resultTasks[jobName] = activitiesTaskPairList.map {it.first}

    } else {
        dependencies[jobName] = prevTaskList
        resultTasks[jobName] = listOf<Task>() // WITHOUT THE <Task> GENERIC, KOTLIN COMPILER BARFS
    }
}


fun getPaths(taskList: List<Task>): List<String> {
    val pathList = mutableListOf<String>()

    for(task in taskList) {
        val json = JsonSlurper().parse(
                task.outputs.files.filter { it.name == "outputPath.json" }.singleFile
        ) as List<*>
        pathList.addAll(json.map { it as String })
    }

    return pathList
}


fun getJobName(job: Map<*,*>): String = job[jobNameConfigKey] as String
fun getCheck(job: Map<*,*>): Boolean = if (job.containsKey("check")) job["check"] as Int != 0 else false


fun getDgResultInput(nodePath: String, outputFile: File, execName: String): String {

    val jsonData = mapOf(
            "Test"        to mapOf(
                "name"      to "Result_Output",
                "src"       to listOf(nodePath),
                "dst"       to listOf<String>(),
                "dst_lec"   to "",
                "exec_name" to "result-$execName"
            ),
            "Output_Name" to outputFile.absolutePath
    )
    return convertToJson(jsonData)
}

fun getTrainingNetInput(trainingNodePathList: List<String>, initialNodePathList: List<String>): String {
    val jsonData = mapOf(
            "1" to mapOf(
                    "dst"     to trainingNodePathList,
                    "dst_lec" to "",
                    "name"    to "LEC_Setup",
                    "src"     to initialNodePathList
            )
    )
    return convertToJson(jsonData)
}

fun createTaskDirs(taskname: String): List<File> {
    val taskDir = File(fileDir, taskname)
    taskDir.mkdirs()

    val taskInputDir = File(taskDir, "input")
    taskInputDir.mkdirs()
    val taskOutputDir = File(taskDir, "output")
    taskOutputDir.mkdirs()

    return listOf(taskInputDir, taskOutputDir)
}

fun getNodeTask(input_file: File): String {
    val jsonData = mapOf(
            "task" to input_file.absolutePath
    )
    return convertToJson(jsonData)
}

//
// ------------------------ ALCModelUpdater Execution ------------------------
//
fun getCommand(configFile: File): List<String> {
    return listOf(
            "node",
            "/alc/webgme/node_modules/webgme-engine/src/bin/run_plugin.js",
            alcPluginName,
            projectName,
            "-a", genericActiveNode,
            "-u", userarg,
            "-o", owner,
            "-l", webgmeUrl,
            "-j", configFile.absolutePath,
            "-n", namespace
    )
}

fun getInspectTaskName(taskName: String): String = "inspect-$taskName"


fun setStatusMessage(message: String): String {
    val jsonData = mapOf(
            "1" to mapOf(
                    "name"       to "Update_Status",
                    "src"        to listOf(statusPath),
                    "dst"        to listOf<String>(),
                    "dst_lec"    to "",
                    "status_msg" to message
            )
    )
    return convertToJson(jsonData)
}

val blocksize = 1024

fun getLastRightBracePos(randomAccessFile: java.io.RandomAccessFile): Long {

    val byteArray = ByteArray(blocksize)

    var oldPos = randomAccessFile.length()
    var pos = oldPos - blocksize
    var bytesToRead = blocksize
    if (pos < 0) {
        pos = 0
        bytesToRead = oldPos.toInt()
    }

    var examineString: String

    var lastBracePos = -1

    while (bytesToRead > 0 && lastBracePos < 0) {

        randomAccessFile.seek(pos)
        randomAccessFile.readFully(byteArray, 0, bytesToRead)
        val readString = String(byteArray, 0, bytesToRead)

        examineString = readString

        lastBracePos = examineString.lastIndexOf('}')

        oldPos = pos
        pos -= bytesToRead
        if (pos < 0) {
            pos = 0
            bytesToRead = oldPos.toInt()
        }
    }

    return if (lastBracePos < 0) lastBracePos.toLong() else oldPos + lastBracePos
}

fun getNewValue(value: Int, searchString: String): Pair<Int,Int> {
    var mutableValue = value

    var newLeftSearchPos = searchString.lastIndexOf('{')
    var oldLeftSearchPos = newLeftSearchPos
    var newRightSearchPos = searchString.lastIndexOf('}')
    var oldRightSearchPos: Int

    while (mutableValue > 0 && (newLeftSearchPos > 0 || newRightSearchPos > 0)) {
        oldLeftSearchPos = newLeftSearchPos
        oldRightSearchPos = newRightSearchPos
        if (oldRightSearchPos > oldLeftSearchPos) {
            mutableValue += 1
            newRightSearchPos = searchString.lastIndexOf('}', oldRightSearchPos - 1)
        } else {
            mutableValue -= 1
            newLeftSearchPos = searchString.lastIndexOf('{', oldLeftSearchPos - 1)
        }
    }

    return Pair(mutableValue, oldLeftSearchPos)
}


fun xOutQuotedText(examineString: String): String {

    var mutableString = examineString

    mutableString = mutableString.replace(Regex("\\\\."), "XX").reversed()

    val patternData = Regex("\"[^\"]*\"").findAll(mutableString)
    for (item in patternData) {
        val charBeforePos = item.range.first - 1
        if (charBeforePos > 0 && mutableString[charBeforePos] != '\\') {
            mutableString = mutableString.replaceRange(item.range, "X".repeat(item.range.count()))
        }
    }

    return mutableString.reversed()
}

fun getJson(file: File): String {

    java.io.RandomAccessFile(file, "r").use {

        var oldPos = getLastRightBracePos(it)
        if (oldPos < 0) return ""

        val byteArray = ByteArray(blocksize)

        var pos = oldPos - blocksize
        var bytesToRead = blocksize
        if (pos < 0) {
            pos = 0
            bytesToRead = oldPos.toInt()
        }

        var examineString = ""
        var actualString = "}"


        var value = 1
        var leftSearchPos = 0
        while (bytesToRead > 0 && value > 0) {

            it.seek(pos)
            it.readFully(byteArray, 0, bytesToRead)
            val readString = String(byteArray, 0, bytesToRead)

//            println("readString = $readString")
            actualString = readString + actualString
            examineString = readString + examineString

            examineString = xOutQuotedText(examineString)

//            println("examineString = $examineString")

            val afterLastQuotePos = examineString.lastIndexOf('"') + 1

            val searchString = examineString.substring(afterLastQuotePos)
            examineString = examineString.substring(0, afterLastQuotePos)

            val pair = getNewValue(value, searchString)
            value = pair.first
            leftSearchPos = pair.second + afterLastQuotePos

            oldPos = pos
            pos -= blocksize
            if (pos < 0) {
                pos = 0
                bytesToRead = oldPos.toInt()
            }

        }

        if (value > 0) return ""

        return actualString.substring(leftSearchPos)
    }

}

fun getUpToDateJson(): MutableMap<String, Any?> {

    val current = LocalDateTime.now().format(dateTimeFormatter)
    return mutableMapOf(
        "success"    to true,
        "messages"   to emptyList<String>(),
        "artifacts"  to emptyList<String>(),
        "pluginName" to "",
        "startTime"  to current,
        "finishTime" to current,
        "error"      to null,
        "projectId"  to "$owner+$projectName",
        "pluginId"   to "",
        "commits"    to emptyList<String>()
    )
}

fun setupInspectTask(execTask: Exec, jobName: String) : Exec {
    val taskName = execTask.name
    val inspectTaskName = getInspectTaskName(taskName)

    val configFunction = { task :Task ->

        task.dependsOn(execTask)

        var statusMap = mutableMapOf<String, Any?>()

        task.doFirst {
            statusMap = if (execTask.state.upToDate) {
                getUpToDateJson()
            } else {
                val statusFile = execTask.outputs.files.filter { it.name == "status.json" }.singleFile
                (JsonSlurper().parse(statusFile) as MutableMap<String, Any?>)
            }
            statusMap["jobName"] = jobName
            statusMap["taskName"] = execTask.name

            val statusJson = StringEscapeUtils.escapeJavaScript(JsonOutput.toJson(statusMap))
            val inputFile: File by task.extra
            inputFile.writeText(setStatusMessage(statusJson))
        }

        task.doLast {
            if (statusMap["error"] != null) {
                throw GradleException(statusMap.getOrDefault("exception", "") as String)
            }
        }

        Unit
    }

    return registerExecTask(
            inspectTaskName,
            primary_input_file = false,
            has_output_file = false,
            up_to_date = false,
            configFunction = configFunction
    )
}

fun registerExecTask(
        taskName: String,
        primary_input_file: Boolean = true,
        has_output_file: Boolean = true,
        up_to_date: Boolean = true,
        configFunction: (Exec) -> Unit = {_ -> },
        prevTaskList: List<Task> = listOf()
): Exec {

    return tasks.register<Exec>(taskName) {

        val taskDirs = createTaskDirs(taskName)
        val inputDir = taskDirs[0]
        val outputDir by extra(taskDirs[1])

        val nodeTaskFile = File(inputDir, "task.json")
        val inputFile by extra(File(inputDir, "input.json"))
        val outputFile by extra(File(outputDir, "output.json"))
        val statusOutputFile = File(outputDir, "status.json")
        val stdOutputFile by extra(File(outputDir, "stdout"))
        val stdErrorFile by extra(File(outputDir, "stderr"))

        nodeTaskFile.writeText(getNodeTask(inputFile))

        inputs.file(nodeTaskFile)
        if (primary_input_file) {
            inputs.file(inputFile)
        }

        outputs.file(statusOutputFile)
        if (has_output_file) {
            outputs.file(outputFile)
        } else {
            outputs.upToDateWhen { up_to_date }
        }

        if (prevTaskList.isNotEmpty()) {
            dependsOn(prevTaskList)
        }

        configFunction(this)

        workingDir = webgmeHomeDir

        standardOutput = stdOutputFile.outputStream()
        errorOutput = stdErrorFile.outputStream()

        commandLine = getCommand(nodeTaskFile)

        isIgnoreExitValue = true

        doLast {
            statusOutputFile.writeText(getJson(stdOutputFile))
        }
    }.get()
}

fun registerInspectedExecTask(
        taskName: String,
        jobName: String,
        primary_input_file: Boolean = true,
        has_output_file: Boolean = true,
        up_to_date: Boolean = true,
        configFunction: (Exec) -> Unit = { _ -> },
        prevTaskList: List<Task> = listOf()
): Pair<Exec, Exec> {

    val execTask = registerExecTask(
            taskName, primary_input_file, has_output_file, up_to_date, configFunction, prevTaskList
    )

    val inspectTask = setupInspectTask(execTask, jobName)

    return Pair(execTask, inspectTask)
}



fun getExecutionCommand(configFile: File, datagen_node: String): List<String> {
    return listOf(
            "node",
            "/alc/webgme/node_modules/webgme-engine/src/bin/run_plugin.js",
            executionPluginName,
            projectName,
            "-a", datagen_node,
            "-u", userarg,
            "-o", owner,
            "-l", webgmeUrl,
            "-j", configFile.absolutePath,
            "-n", namespace
    )
}

//
// ------------------------ ExecuteExpt Execution ------------------------
//

fun registerExperimentTask(
        jobName: String,
        activeNodeName: String,
        activeNodePath: String,
        execName: String,
        taskName: String,
        prevTaskList: List<Task>
) : Pair<Exec, Exec> {

    val execTask = tasks.register<Exec>(taskName) {

        val taskDirs = createTaskDirs(taskName)

        val inputDir = taskDirs[0]
        val outputDir = taskDirs[1]

        val nodeTaskFile = File(inputDir, "task.json")
        val statusOutputFile = File(outputDir, "status.json")
        val stdOutputFile = File(outputDir, "stdout")
        val stdErrorFile = File(outputDir, "stderr")

        val jobUpdateMap = updateJobInfoMap[jobName] as Map<*,*>? ?: mapOf()
        val activityUpdateMap = (jobUpdateMap[defaultParameterValuesUpdateKey] as Map<*,*>? ?: mapOf()).toMutableMap()
        activityUpdateMap.putAll(
                (jobUpdateMap[activityParameterValueUpdateKey] as Map<*,*>?)
                        ?.get(activeNodeName) as Map<*,*>? ?: mapOf()
        )

        nodeTaskFile.writeText(getExecution(execName, activityUpdateMap))

        inputs.file(nodeTaskFile)
        outputs.files(statusOutputFile)
        outputs.upToDateWhen { true }

        if (prevTaskList.isNotEmpty()) {
            dependsOn(prevTaskList)
        }

        workingDir = webgmeHomeDir

        standardOutput = stdOutputFile.outputStream()
        errorOutput = stdErrorFile.outputStream()

        commandLine = getExecutionCommand(nodeTaskFile, activeNodePath)

        isIgnoreExitValue = true

        doLast {
            statusOutputFile.writeText(getJson(stdOutputFile))
        }

    }.get()

    val inspectTask = setupInspectTask(execTask, jobName)

    return Pair(execTask, inspectTask)
}

fun updateUpdatesFile(
        updatesFile: File, nextMainIteration: Int, jobName: String, jobIteration: Int, restartAtJob: String?
) {
    val updateJson = JsonSlurper().parse(updatesFile) as MutableMap<String, MutableMap<String, Any>>

    val updateControlInfoJson = updateJson.computeIfAbsent(controlInfoKey) {k -> mutableMapOf()}
    updateControlInfoJson[mainIterationKey] = nextMainIteration
    updateControlInfoJson[iterationJobNameKey] = jobName
    updateControlInfoJson[jobIterationKey] = jobIteration
    if (restartAtJob != null && restartAtJob.isNotBlank()) {
        updateControlInfoJson[restartAtJobUpdateKey] = restartAtJob
    }
    updatesFile.writeText(convertToJson(updateJson))
}

fun getDateTime(eventTime: Long): String {
    return LocalDateTime
            .ofInstant(Instant.ofEpochMilli(eventTime), TimeZone.getTimeZone("UTC").toZoneId())
            .format(dateTimeFormatter)
}

fun getStatusJson(
        success: Boolean,
        startTime: Long,
        finishTime: Long,
        error: Int?,
        stdout: String,
        stderr: String,
        exception: String?
): Map<String, Any?> {
    val startDateTime = getDateTime(startTime)
    val finishDateTime = getDateTime(finishTime)
    return mutableMapOf(
            "success"    to success,
            "messages"   to emptyList<String>(),
            "artifacts"  to emptyList<String>(),
            "pluginName" to "",
            "startTime"  to startDateTime,
            "finishTime" to finishDateTime,
            "error"      to error,
            "projectId"  to "$owner+$projectName",
            "pluginId"   to "",
            "commits"    to emptyList<String>(),
            "stdout"     to stdout,
            "stderr"     to stderr,
            "exception"  to exception
    )
}


fun registerEvaluateTask(
        jobName: String,
        localCheckScriptPath: String,
        maxIterations: Int,
        restartAtJob: String?,
        prevTaskList: List<Task>
): Pair<Exec, Exec> {

    val jobIteration = if (iterationJobName == jobName) jobIteration + 1 else 0
    val nextJobIteration = jobIteration + 1
    val nextMainIteration = mainIteration + 1
    val nextIterationDirName = "iteration-$nextMainIteration-$jobName-$nextJobIteration"
    val nextIterationDir = File(runDir, nextIterationDirName)
    val evaluateTaskName = "evaluate-$jobName"

    val execTask = tasks.register<Exec>(evaluateTaskName) {
        val checkFile = getCheckFile(iterationDir)
        val updatesFile = getUpdatesFile(iterationDir)

        val taskDirs = createTaskDirs(evaluateTaskName)
        val outputDir = taskDirs[1]

        val statusOutputFile by extra(File(outputDir, "status.json"))
        val stdOutputFile by extra(File(outputDir, "stdout"))
        val stdErrorFile by extra(File(outputDir, "stderr"))

        outputs.files(statusOutputFile, updatesFile)

        standardOutput = stdOutputFile.outputStream()
        errorOutput = stdErrorFile.outputStream()

        environment.compute("PYTHONPATH") { _, v ->
            v as String?
            val appendValue = File(projectDir, "src/main/python").absolutePath
            if (v == null || v.isBlank()) {
                appendValue
            } else {
                "$v:$appendValue"
            }
        }

        commandLine = listOf(
                "python3", localCheckScriptPath, "--${workflowDirOption}", runDir.absolutePath
        )

        isIgnoreExitValue = true

        if (prevTaskList.isNotEmpty()) {
            dependsOn(prevTaskList)
        }

        var startTime = 0L
        var finishTime: Long

        doFirst {
            if (jobInfoMap.isEmpty() || localCheckScriptPath.isBlank()) {
                writeLoopFile()
                statusOutputFile.writeText(convertToJson(getUpToDateJson()))
                throw StopExecutionException()
            }

            controlInfoMap[mainIterationKey] = mainIteration
            controlInfoMap[jobIterationKey] = jobIteration
            controlInfoMap[iterationJobNameKey] = jobName

            checkFile.writeText(convertToJson(checkMap))

            startTime = System.currentTimeMillis()
        }

        doLast {
            finishTime = System.currentTimeMillis()

            var success = true
            var error: Int? = null
            var exception: String? = null

            when {
                execResult.exitValue != 0 -> {
                    writeLoopFile()
                    error = execResult.exitValue
                    success = false
                    exception = "Check script \"$localCheckScriptPath\" for job \"$jobName\"" +
                            " has incurred an error.  Stopping workflow."
                }
                updatesFile.length() != 0L -> {
                    if (nextJobIteration > maxIterations) {
                        error = 0
                        exception = "Check script \"$localCheckScriptPath\" for job \"$jobName\"" +
                                " has indicated that a loop should occur, but max iterations ($maxIterations)" +
                                " exceeeded.  Stopping workflow."
                        writeLoopFile()
                    } else {
                        updateUpdatesFile(updatesFile, nextMainIteration, jobName, jobIteration, restartAtJob)
                        error = 0
                        exception = "Check script \"$localCheckScriptPath\" for job \"$jobName\"" +
                                " has indicated that a loop should occur"
                        writeLoopFile(nextIterationDir)
                    }
                }
                else -> writeLoopFile()
            }

            val statusJson = getStatusJson(
                    success,
                    startTime,
                    finishTime,
                    error,
                    stdOutputFile.readText(),
                    stdErrorFile.readText(),
                    exception
            )

            statusOutputFile.writeText(convertToJson(statusJson))
        }
    }.get()

    val inspectTask = setupInspectTask(execTask, evaluateTaskName)

    return Pair(execTask, inspectTask)
}

fun getExecution(dataName: String, update: Any?): String {
    val jsonData = mapOf(
            "name"              to dataName,
            "setupJupyterNB"    to false,
            "generateROSLaunch" to false,
            "ParamUpdates"      to (update ?: mapOf<String, Any>())
    )
    return convertToJson(jsonData)
}
