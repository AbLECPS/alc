/*
 * generated by Xtext 2.25.0
 */
package edu.vanderbilt.isis.alc.btree.serializer;

import com.google.inject.Inject;
import edu.vanderbilt.isis.alc.btree.bTree.Arg;
import edu.vanderbilt.isis.alc.btree.bTree.BBEvent;
import edu.vanderbilt.isis.alc.btree.bTree.BBNode;
import edu.vanderbilt.isis.alc.btree.bTree.BBVar;
import edu.vanderbilt.isis.alc.btree.bTree.BTree;
import edu.vanderbilt.isis.alc.btree.bTree.BTreePackage;
import edu.vanderbilt.isis.alc.btree.bTree.BaseArrayType;
import edu.vanderbilt.isis.alc.btree.bTree.BehaviorModel;
import edu.vanderbilt.isis.alc.btree.bTree.CheckBTNode;
import edu.vanderbilt.isis.alc.btree.bTree.DefaultType;
import edu.vanderbilt.isis.alc.btree.bTree.Field;
import edu.vanderbilt.isis.alc.btree.bTree.MessageType;
import edu.vanderbilt.isis.alc.btree.bTree.MonBTNode;
import edu.vanderbilt.isis.alc.btree.bTree.ParBTNode;
import edu.vanderbilt.isis.alc.btree.bTree.SIFBTNode;
import edu.vanderbilt.isis.alc.btree.bTree.SelBTNode;
import edu.vanderbilt.isis.alc.btree.bTree.SeqBTNode;
import edu.vanderbilt.isis.alc.btree.bTree.SimpleType;
import edu.vanderbilt.isis.alc.btree.bTree.StdBehaviorNode;
import edu.vanderbilt.isis.alc.btree.bTree.TaskBTNode;
import edu.vanderbilt.isis.alc.btree.bTree.TaskNode;
import edu.vanderbilt.isis.alc.btree.bTree.TimerBTNode;
import edu.vanderbilt.isis.alc.btree.bTree.Topic;
import edu.vanderbilt.isis.alc.btree.bTree.TopicArg;
import edu.vanderbilt.isis.alc.btree.services.BTreeGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class BTreeSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BTreeGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BTreePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BTreePackage.ARG:
				sequence_Arg(context, (Arg) semanticObject); 
				return; 
			case BTreePackage.BB_EVENT:
				sequence_BBEvent(context, (BBEvent) semanticObject); 
				return; 
			case BTreePackage.BB_NODE:
				sequence_BBNode(context, (BBNode) semanticObject); 
				return; 
			case BTreePackage.BB_VAR:
				if (rule == grammarAccess.getBBVarRule()) {
					sequence_BBVar(context, (BBVar) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCheckNodeRule()) {
					sequence_CheckNode(context, (BBVar) semanticObject); 
					return; 
				}
				else break;
			case BTreePackage.BTREE:
				sequence_BTree(context, (BTree) semanticObject); 
				return; 
			case BTreePackage.BASE_ARRAY_TYPE:
				sequence_BaseArrayType(context, (BaseArrayType) semanticObject); 
				return; 
			case BTreePackage.BEHAVIOR_MODEL:
				sequence_BehaviorModel(context, (BehaviorModel) semanticObject); 
				return; 
			case BTreePackage.CHECK_BT_NODE:
				sequence_CheckBTNode(context, (CheckBTNode) semanticObject); 
				return; 
			case BTreePackage.DEFAULT_TYPE:
				sequence_DefaultType(context, (DefaultType) semanticObject); 
				return; 
			case BTreePackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case BTreePackage.MESSAGE_TYPE:
				sequence_MessageType(context, (MessageType) semanticObject); 
				return; 
			case BTreePackage.MON_BT_NODE:
				sequence_MonBTNode(context, (MonBTNode) semanticObject); 
				return; 
			case BTreePackage.PAR_BT_NODE:
				sequence_ParBTNode(context, (ParBTNode) semanticObject); 
				return; 
			case BTreePackage.SIFBT_NODE:
				sequence_SIFBTNode(context, (SIFBTNode) semanticObject); 
				return; 
			case BTreePackage.SEL_BT_NODE:
				sequence_SelBTNode(context, (SelBTNode) semanticObject); 
				return; 
			case BTreePackage.SEQ_BT_NODE:
				sequence_SeqBTNode(context, (SeqBTNode) semanticObject); 
				return; 
			case BTreePackage.SIMPLE_TYPE:
				sequence_SimpleType(context, (SimpleType) semanticObject); 
				return; 
			case BTreePackage.STD_BEHAVIOR_NODE:
				sequence_StdBehaviorNode(context, (StdBehaviorNode) semanticObject); 
				return; 
			case BTreePackage.TASK_BT_NODE:
				sequence_TaskBTNode(context, (TaskBTNode) semanticObject); 
				return; 
			case BTreePackage.TASK_NODE:
				sequence_TaskNode(context, (TaskNode) semanticObject); 
				return; 
			case BTreePackage.TIMER_BT_NODE:
				sequence_TimerBTNode(context, (TimerBTNode) semanticObject); 
				return; 
			case BTreePackage.TOPIC:
				sequence_Topic(context, (Topic) semanticObject); 
				return; 
			case BTreePackage.TOPIC_ARG:
				sequence_TopicArg(context, (TopicArg) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Arg returns Arg
	 *
	 * Constraint:
	 *     (type=[Type|ID] (array='[' count=INT?)? name=ID default=DefaultType?)
	 */
	protected void sequence_Arg(ISerializationContext context, Arg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BBEvent returns BBEvent
	 *
	 * Constraint:
	 *     (name=ID topic=[Topic|ID])
	 */
	protected void sequence_BBEvent(ISerializationContext context, BBEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.BB_EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.BB_EVENT__NAME));
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.BB_EVENT__TOPIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.BB_EVENT__TOPIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBBEventAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBBEventAccess().getTopicTopicIDTerminalRuleCall_2_0_1(), semanticObject.eGet(BTreePackage.Literals.BB_EVENT__TOPIC, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BBNode returns BBNode
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         input_topic=[Topic|ID] 
	 *         topic_bbvar=[BBVar|ID] 
	 *         bb_vars+=BBVar* 
	 *         args+=Arg* 
	 *         comment=STRING?
	 *     )
	 */
	protected void sequence_BBNode(ISerializationContext context, BBNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BBVar returns BBVar
	 *
	 * Constraint:
	 *     (type=[Type|ID] name=ID default=BASETYPE?)
	 */
	protected void sequence_BBVar(ISerializationContext context, BBVar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BTree returns BTree
	 *
	 * Constraint:
	 *     btree=BTreeNode
	 */
	protected void sequence_BTree(ISerializationContext context, BTree semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.BTREE__BTREE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.BTREE__BTREE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBTreeAccess().getBtreeBTreeNodeParserRuleCall_0(), semanticObject.getBtree());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DefaultType returns BaseArrayType
	 *     BaseArrayType returns BaseArrayType
	 *
	 * Constraint:
	 *     (values+=BASETYPE values+=BASETYPE*)
	 */
	protected void sequence_BaseArrayType(ISerializationContext context, BaseArrayType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BehaviorModel returns BehaviorModel
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         simpleTypes+=SimpleType* 
	 *         messageTypes+=MessageType* 
	 *         rosTopics+=Topic* 
	 *         bbVariables+=BBVar* 
	 *         bbEvents+=BBEvent* 
	 *         bbNodes+=BBNode* 
	 *         checkNodes+=CheckNode* 
	 *         taskNodes+=BehaviorNode* 
	 *         updatetime=FLOAT 
	 *         timeout=FLOAT 
	 *         tree=BTree
	 *     )
	 */
	protected void sequence_BehaviorModel(ISerializationContext context, BehaviorModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BTreeNode returns CheckBTNode
	 *     ChildNode returns CheckBTNode
	 *     CheckBTNode returns CheckBTNode
	 *
	 * Constraint:
	 *     (check+=[CheckNode|ID] check+=[CheckNode|ID]*)
	 */
	protected void sequence_CheckBTNode(ISerializationContext context, CheckBTNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CheckNode returns BBVar
	 *
	 * Constraint:
	 *     (name=ID bbvar=[BBVar|ID] default=BASETYPE)
	 */
	protected void sequence_CheckNode(ISerializationContext context, BBVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.BB_VAR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.BB_VAR__NAME));
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.BB_VAR__BBVAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.BB_VAR__BBVAR));
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.BB_VAR__DEFAULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.BB_VAR__DEFAULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckNodeAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCheckNodeAccess().getBbvarBBVarIDTerminalRuleCall_3_0_1(), semanticObject.eGet(BTreePackage.Literals.BB_VAR__BBVAR, false));
		feeder.accept(grammarAccess.getCheckNodeAccess().getDefaultBASETYPEParserRuleCall_5_0(), semanticObject.getDefault());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DefaultType returns DefaultType
	 *
	 * Constraint:
	 *     {DefaultType}
	 */
	protected void sequence_DefaultType(ISerializationContext context, DefaultType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (type=[Type|ID] (array='[' count=INT?)? name=ID)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageType returns MessageType
	 *     Type returns MessageType
	 *
	 * Constraint:
	 *     (name=ID package=ID fields+=Field*)
	 */
	protected void sequence_MessageType(ISerializationContext context, MessageType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BTreeNode returns MonBTNode
	 *     ChildNode returns MonBTNode
	 *     MonBTNode returns MonBTNode
	 *
	 * Constraint:
	 *     (mon+=[BBNode|ID] mon+=[BBNode|ID]*)
	 */
	protected void sequence_MonBTNode(ISerializationContext context, MonBTNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BTreeNode returns ParBTNode
	 *     ChildNode returns ParBTNode
	 *     ParBTNode returns ParBTNode
	 *
	 * Constraint:
	 *     (name=ID cond=Status? nodes+=ChildNode*)
	 */
	protected void sequence_ParBTNode(ISerializationContext context, ParBTNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BTreeNode returns SIFBTNode
	 *     ChildNode returns SIFBTNode
	 *     SIFBTNode returns SIFBTNode
	 *
	 * Constraint:
	 *     (name=ID checks+=[CheckNode|ID] checks+=[CheckNode|ID]* nodes+=ChildNode nodes+=ChildNode*)
	 */
	protected void sequence_SIFBTNode(ISerializationContext context, SIFBTNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BTreeNode returns SelBTNode
	 *     ChildNode returns SelBTNode
	 *     SelBTNode returns SelBTNode
	 *
	 * Constraint:
	 *     (name=ID cond=Status? nodes+=ChildNode*)
	 */
	protected void sequence_SelBTNode(ISerializationContext context, SelBTNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BTreeNode returns SeqBTNode
	 *     ChildNode returns SeqBTNode
	 *     SeqBTNode returns SeqBTNode
	 *
	 * Constraint:
	 *     (name=ID cond=Status? nodes+=ChildNode*)
	 */
	protected void sequence_SeqBTNode(ISerializationContext context, SeqBTNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleType returns SimpleType
	 *     Type returns SimpleType
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SimpleType(ISerializationContext context, SimpleType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BehaviorNode returns StdBehaviorNode
	 *     StdBehaviorNode returns StdBehaviorNode
	 *
	 * Constraint:
	 *     (type=STD_BEHAVIOR_TYPE name=ID)
	 */
	protected void sequence_StdBehaviorNode(ISerializationContext context, StdBehaviorNode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.STD_BEHAVIOR_NODE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.STD_BEHAVIOR_NODE__TYPE));
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.BEHAVIOR_NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.BEHAVIOR_NODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStdBehaviorNodeAccess().getTypeSTD_BEHAVIOR_TYPEParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getStdBehaviorNodeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BTreeNode returns TaskBTNode
	 *     ChildNode returns TaskBTNode
	 *     TaskBTNode returns TaskBTNode
	 *
	 * Constraint:
	 *     (task+=[BehaviorNode|ID] task+=[BehaviorNode|ID]*)
	 */
	protected void sequence_TaskBTNode(ISerializationContext context, TaskBTNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BehaviorNode returns TaskNode
	 *     TaskNode returns TaskNode
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (input_topics+=TopicArg input_topics+=TopicArg*)? 
	 *         (output_topics+=TopicArg output_topics+=TopicArg*)? 
	 *         bb_vars+=BBVar* 
	 *         args+=Arg* 
	 *         comment=STRING?
	 *     )
	 */
	protected void sequence_TaskNode(ISerializationContext context, TaskNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BTreeNode returns TimerBTNode
	 *     ChildNode returns TimerBTNode
	 *     TimerBTNode returns TimerBTNode
	 *
	 * Constraint:
	 *     (name=ID duration=NUMBER)
	 */
	protected void sequence_TimerBTNode(ISerializationContext context, TimerBTNode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.TIMER_BT_NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.TIMER_BT_NODE__NAME));
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.TIMER_BT_NODE__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.TIMER_BT_NODE__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimerBTNodeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTimerBTNodeAccess().getDurationNUMBERParserRuleCall_3_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopicArg returns TopicArg
	 *
	 * Constraint:
	 *     (type=[Topic|ID] name=ID)
	 */
	protected void sequence_TopicArg(ISerializationContext context, TopicArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.TOPIC_ARG__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.TOPIC_ARG__TYPE));
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.TOPIC_ARG__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.TOPIC_ARG__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTopicArgAccess().getTypeTopicIDTerminalRuleCall_0_0_1(), semanticObject.eGet(BTreePackage.Literals.TOPIC_ARG__TYPE, false));
		feeder.accept(grammarAccess.getTopicArgAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Topic returns Topic
	 *
	 * Constraint:
	 *     (type=[MessageType|ID] name=ID topic_string=STRING)
	 */
	protected void sequence_Topic(ISerializationContext context, Topic semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.TOPIC__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.TOPIC__TYPE));
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.TOPIC__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.TOPIC__NAME));
			if (transientValues.isValueTransient(semanticObject, BTreePackage.Literals.TOPIC__TOPIC_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BTreePackage.Literals.TOPIC__TOPIC_STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTopicAccess().getTypeMessageTypeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(BTreePackage.Literals.TOPIC__TYPE, false));
		feeder.accept(grammarAccess.getTopicAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTopicAccess().getTopic_stringSTRINGTerminalRuleCall_3_0(), semanticObject.getTopic_string());
		feeder.finish();
	}
	
	
}
