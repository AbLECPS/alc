/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 2.16.0 from webgme on Fri Dec 22 2017 23:00:15 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'plugin/ImportRequirement/ImportRequirement/meta',
	'./xmljsonconverter',
    'common/util/guid'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    MetaTypes,
	Converters, 
	GUID) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of ImportRequirement.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin ImportRequirement.
     * @constructor
     */
    var ImportRequirement = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
        this.pluginMetadata = pluginMetadata;
		this.keys= ["name", "usedElements","packagedElement","sysml:Requirement","sysml:extendedRequirement","sysml:Copy", "sysml:Refine","sysml:DeriveReqt","sysml:Satisfy","sysml:Verify","sysml:Trace"];
		this.connectionTypes=["Copy", "Refine","DeriveReqt","Satisfy","Verify","Trace"];
		this.xmlObjs={};
		this.nodeObjs={};
		this.connectionObjs ={};
		this.model='';
		this.nodes={};
		this.conns={};
		this.nodesPath={};
		this.nodesID={};
		this.nodeObjskeys=[];
		this.connObjskeys=[];
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    ImportRequirement.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    ImportRequirement.prototype = Object.create(PluginBase.prototype);
    ImportRequirement.prototype.constructor = ImportRequirement;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    ImportRequirement.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            config = self.getCurrentConfig(),
			len,
			i,j,
            xml2json = new Converters.Xml2json({
                skipWSText: true
				/*,
				arrayElements: {
                    packagedElement: true,
					nestedClassifier: true,
					usedElements: true,
					client: true,
					supplier: true,
					extendedRequirement: true,
					Requirement: true,
					Verify: true,
					Trace: true,
					Satisfy: true,
					DeriveReqt: true,
					Copy: true,
					Refine: true
                }*/
            }),
            xmlData;

        self.updateMETA(self.metaTypes);
		
		var len = self.keys.length;
		for(i=0; i!= len; i+=1)
		{
			self.xmlObjs[self.keys[i]] = [];
		}

        // Using the logger.
		
		
        self.logger.debug('Checking configuration');

        if (!config.reqModel) {
            self.createMessage(null, 'A Requirement Model (XML file) must be provided.', 'error');
            callback(null, self.result);
            return;
        }

        self.logger.debug('Getting requirement model content');
        self.sendNotification('Getting requirement model file');

        self.blobClient.getObject(config.reqModel, function (err, xmlArrayBuffer) {
            var error;

            if (err) {
                callback(err, self.result);
                return;
            }

            self.logger.debug('Got Requirement model file content, converting it to json');
            if (typeof xmlArrayBuffer === 'string') {
                xmlData = xml2json.convertFromString(xmlArrayBuffer);
            } else {
                xmlData = xml2json.convertFromBuffer(xmlArrayBuffer);
            }
			
			self.logger.debug(xmlData);

            self.sendNotification({message: 'Got requirement model file content, processing data...', progress: 10});
			var keys = Object.keys(xmlData);
			var obj = xmlData[keys[0]];
			keys = Object.keys(obj);
			self.logger.debug(keys);
			
			
			
			self.xmlObjs["name"] = obj["uml:Model"]["xmi:Extension"]["modelExtension"]["ownedDiagram"]["@name"];
			self.logger.debug(" added name");
			var modeldiagram = obj["uml:Model"]["xmi:Extension"]["modelExtension"]["ownedDiagram"]["xmi:Extension"]["diagramRepresentation"];
			var keys1 = Object.keys(modeldiagram);
			self.xmlObjs["usedElements"] = modeldiagram[keys1[0]]["diagramContents"]["usedElements"];	
			self.logger.debug(" added usedElements");
			//self.logger.debug(modelobjects[0]["#text"]);
			self.xmlObjs["packagedElement"] = obj["uml:Model"]["packagedElement"];
			self.logger.debug(" added packagedElement");
			
			self.logger.debug(" keys found " + keys);
			for(i=3; i!= len; i+=1)
			{
				self.logger.debug( self.keys[i]);
				if (keys.indexOf(self.keys[i]) > -1)
				{
					self.xmlObjs[self.keys[i]]=obj[self.keys[i]];
					if (Array.isArray(self.xmlObjs[self.keys[i]]))
						self.logger.debug(" added " + self.keys[i] + " length " + self.xmlObjs[self.keys[i]].length);
					else
						self.logger.debug(" added " + self.keys[i] + " keys " + Object.keys(self.xmlObjs[self.keys[i]]));
					
				}
				else
				{
					self.logger.debug(" not found " + self.keys[i]);
				}
			}
			
			var plen = self.xmlObjs["packagedElement"].length;
			for(i=0; i!= plen; i+=1)
			{
				var pobj = self.xmlObjs["packagedElement"][i];
				self.addObjInfo1(pobj);
			}
			
			
			for(i=3; i!= self.keys.length; i+=1)
			{
				if (keys.indexOf(self.keys[i]) > -1)
				{
					
					if (Array.isArray(self.xmlObjs[self.keys[i]]))
					{
						for( j=0; j!= self.xmlObjs[self.keys[i]].length; j+=1)
						{
							if (i<5)
							{
								self.addObjInfo2(self.xmlObjs[self.keys[i]][j]);
							}
							else
							{
								self.addObjInfo3(i, self.xmlObjs[self.keys[i]][j]);
							}
						}
						
					}
					else
					{
						if (i<5)
						{
							self.addObjInfo2(self.xmlObjs[self.keys[i]]);
						}
						else
						{
							self.addObjInfo3(i, self.xmlObjs[self.keys[i]]);
						}
						
					}
					
				}
				
				
			}
			
            /*error = self.processParadigm(xmlData);

            if (error) {
                self.result.setSuccess(false);
                self.result.setError(error.message);
                callback(error.stack, self.result);
                return;
            }*/
			self.createModel();

            self.sendNotification({message: 'Data processed, saving model', progress: 60});
            self.save('Imported Requirement  model ', function (err) {
                if (err) {
                    self.result.setSuccess(false);
                    self.result.setError(err);
                }
				self.result.setSuccess(true);
                self.sendNotification({message: 'Model saved, plugin done', progress: 100, severity: 'success'});
                callback(null, self.result);
            });
        });
        

		/*
        // This will save the changes. If you don't want to save;
        // exclude self.save and call callback directly from this scope.
        self.save('ImportRequirement updated model.')
            .then(function () {
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                // Result success is false at invocation.
                callback(err, self.result);
            });
			
		*/

    };
	
	ImportRequirement.prototype.addObjInfo1 = function (pobj,childid='') {
		var self = this;
		
		var pkeys =Object.keys(pobj);
		var id = '';
		if (pkeys.indexOf("@xmi:id") ==-1)
			return;
		
		id =pobj["@xmi:id"];
		
		var pname = '';
		if (pkeys.indexOf("@name") !=-1)
		{
			name =pobj["@name"];
			self.nodeObjs[id] = {n: name, id: '', t: '', dr: '', tt:'', r:'', vm:'', c:[]};
			self.nodeObjskeys.push(id);
			if (childid != '')
			{
					self.nodeObjs[id].c.push(childid);
			}
			if (pkeys.indexOf("nestedClassifier") !=-1)
				self.addNCInfo(pobj["nestedClassifier"],id);

		}
		
		var cobj='';
		var cid ='';
		var sid = '';
		var sobj ='';
		
		if (pkeys.indexOf("client") !=-1 && pkeys.indexOf("supplier") !=-1)
		{
			cobj =pobj["client"];
			cid = cobj["@xmi:idref"];
			sobj =pobj["supplier"];
			sid = sobj["@xmi:idref"];
			self.connectionObjs[id] = {c:cid, s:sid, t:''};
			self.connObjskeys.push(id);
		}
		
	
	};
	
	ImportRequirement.prototype.addObjInfo2 = function (pobj) {
		var self = this;
		
		var pkeys =Object.keys(pobj);
		var id = '';
		if (pkeys.indexOf("@base_Class") ==-1)
			return;
		
		id =pobj["@base_Class"];
		
		
		
		if (self.nodeObjskeys.indexOf(id) == -1)
		{
			self.logger.debug(' node was not found ' + id);
			return;
		}
		
		if (pkeys.indexOf("@Id") !=-1)
		{
			self.nodeObjs[id].id= pobj["@Id"];
		}
		if (pkeys.indexOf("@Text") !=-1)
		{
			self.nodeObjs[id].t= pobj["@Text"];
		}

		if (pkeys.indexOf("@DerivedFrom") !=-1)
		{
			self.nodeObjs[id].dr= pobj["@DerivedFrom"];
		}
		if (pkeys.indexOf("@TraceTo") !=-1)
		{
			self.nodeObjs[id].tt= pobj["@TraceTo"];
		}
		if (pkeys.indexOf("@risk") !=-1)
		{
			self.nodeObjs[id].r= pobj["@risk"];
		}
		if (pkeys.indexOf("@verifyMethod") !=-1)
		{
			self.nodeObjs[id].vm= pobj["@verifyMethod"];
		}
	
	};
	
	ImportRequirement.prototype.addObjInfo3 = function (i, pobj) {
		var self = this;
		
		var pkeys =Object.keys(pobj);
		var id = '';
		if (pkeys.indexOf("@base_Abstraction") ==-1)
			return;
		
		id =pobj["@base_Abstraction"];
		
		if (self.connObjskeys.indexOf(id) == -1)
		{
			self.logger.debug(' connection obj was not found ' + id);
			return;
		}
		
		self.connectionObjs[id].t= i-5;
		
	};
	
	
	
	ImportRequirement.prototype.addNCInfo = function (pobj, childid) {
		var self = this;
		var i =0;
		
		if (!Array.isArray(pobj))
		{
			self.addObjInfo1(pobj,childid);
		}
		else{
			for(i=0;i!= pobj.length; i+=1)
			{
				self.addObjInfo1(pobj[i],childid);
			}
			
		}
		
	};
	
	ImportRequirement.prototype.createModel = function (name) {
		var self = this;
		self.model = self.core.createNode({
            parent: self.activeNode,
            base: self.META.Requirements_Model
			});
		var path = self.core.getPath(self.model)
		self.nodesPath[path] = self.model;
		self.core.setAttribute(self.model,'name',self.xmlObjs["name"]);
		self.createNodes();
		self.createConns();
	};
	
	ImportRequirement.prototype.createNodes = function () {
		var self = this;
		var keys = Object.keys(self.nodeObjs);
		var i,x,y;
		for(i=0; i!=keys.length; i+=1)
		{
			var key = keys[i];
			var obj = self.nodeObjs[key];
			var node = self.core.createNode({
				parent: self.model,
				base: self.META.Requirement
				});
				
			self.core.setAttribute(node, 'name', obj.n);
			self.core.setAttribute(node, 'Id', obj.id);
			self.core.setAttribute(node, 'Text', obj.t);
			self.core.setAttribute(node, 'Risk', obj.r);
			
			var path = self.core.getPath(node);
			self.nodesPath[path] = node;
			self.nodesID[key] = path;
			
			x = 100 + i*250;
			y = 100 +i*250;

			self.core.setRegistry(node, 'position', {x: x, y: y});

		}
		
	};
	
	ImportRequirement.prototype.createConns = function () {
		var self = this;
		var keys = Object.keys(self.connectionObjs);
		var i, j;
		for(i=0; i!=keys.length; i+=1)
		{
			var key = keys[i];
			var obj = self.connectionObjs[key];
			var cpath = self.nodesID[obj.c];
			var spath = self.nodesID[obj.s];
			var c = self.nodesPath[cpath];
			var s = self.nodesPath[spath];
			
			if (self.nodeObjs[obj.c].c.length > 0)
			{
				if (self.nodeObjs[obj.c].c.indexOf(obj.s) != -1)
				{
					continue;
				}
			}
			
			var node = self.core.createNode({
				parent: self.model,
				base: self.META.ReqConn
				});
				
			self.core.setAttribute(node, 'Type', self.connectionTypes[obj.t]);
			
			self.core.setPointer(node, 'src', c);
			self.core.setPointer(node, 'dst', s);
			
			
			var path = self.core.getPath(node);
			self.nodesPath[path] = node;
			self.nodesID[key] = path;
		}
		keys = Object.keys(self.nodeObjs);
		
		for(i=0; i!=keys.length; i+=1)
		{
			var key = keys[i];
			var obj = self.nodeObjs[key];
			var cpath = self.nodesID[key];
			
			var c = self.nodesPath[cpath];
			
			if (obj.c.length == 0)
				continue;
			for(j=0;j!=obj.c.length; j+=1)
			{
				var key1 = obj.c[j];
				var spath = self.nodesID[key1];
				var s = self.nodesPath[spath];
				var node = self.core.createNode({
				parent: self.model,
				base: self.META.ReqConn
				});
				self.core.setAttribute(node, 'Type', 'Sub-requirement');
				self.core.setPointer(node, 'src', c);
				self.core.setPointer(node, 'dst', s);
				var path = self.core.getPath(node);
				self.nodesPath[path] = node;
				//self.nodesID[key] = path;
			}
			
		}
		
		
	};

	
	ImportRequirement.prototype.processParadigm = function (xmlData) {
		var self = this;
		
		 self.logger.debug('Processing given requirement model');

         self.result.setSuccess(true);
		 
		 

		
	};
	/*
	
    };
	*/

    


    return ImportRequirement;
});
