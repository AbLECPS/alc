/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Tue Aug 30 2016 13:34:25 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'plugin/SMCodeGen/SMCodeGen/meta',
    'common/util/ejs',
    'text!plugin/SMCodeGen/SMCodeGen/Templates/SM_Code_h.txt',
	'text!plugin/SMCodeGen/SMCodeGen/Templates/SM_Code_cpp.txt',
	'q'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    MetaTypes,
    ejs,
    TEMPLATES_H,
	TEMPLATES_CPP,
	Q) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of SMCodeGen.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin SMCodeGen.
     * @constructor
     */
    var SMCodeGen = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
        this.pluginMetadata = pluginMetadata;

        this.nodes = {};

        this.events = {};
        this.eventsID = {};
        this.eventNames = [];
        this.variables = {};
        this.variableNames = [];

        this.states = {};
        this.statesID = {};
        this.statesPathToID = {};
        this.stateIDToRegionID = {};

        this.headercode = TEMPLATES_H;
        this.sourcecode = TEMPLATES_CPP;
        this.smname = '';



        this.vargetsetfn = '';
        this.eventfndecl = '';
        this.vardecl = '';
        this.headerspaces = '		';

        this.eventfndef = '';
        this.statesregion = '';
        this.statesduring = '';
        this.statesentry = '';
        this.statesexit = '';
        this.stateCounter = 0;

        this.transitions = [];
        this.transCounter = 0;
        this.connectorsTraversed = [];
        this.tgfndecl = '';
        this.tgfndef = '';
        this.tgfnchoice = '';
        this.tafndecl = '';
        this.tafndef = '';
        this.tafnchoice = '';
        this.ttfndecl = '';
        this.ttfndef = '';
        this.ttfnchoice = '';
        this.transcreation = '';




    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    SMCodeGen.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    SMCodeGen.prototype = Object.create(PluginBase.prototype);
    SMCodeGen.prototype.constructor = SMCodeGen;

    SMCodeGen.prototype.generateEventCode = function (nodeObject) {
        var self = this;
        var i = 0;
        var eventfndef = '\nbool SM_<SMNAME>::DataSource::<ENAME>()\n{\n	return ProcessEvent(<EID>);\n}\n\n'
        eventfndef = eventfndef.replace(/<SMNAME>/g, self.smname);

        self.eventNames.sort();
        for (i = 0; i != self.eventNames.length; i += 1) {
            self.eventsID[self.eventNames[i]] = i + 1;
            self.eventfndecl += self.headerspaces + 'bool ' + self.eventNames[i] + '();\n'
            var eventcode = eventfndef.slice(0);
            eventcode = eventfndef.replace(/<ENAME>/g, self.eventNames[i]);
            eventcode = eventcode.replace(/<EID>/g, self.eventsID[self.eventNames[i]].toString());
            self.eventfndef += eventcode;
        }

        eventfndef = '\nbool SM_<SMNAME>::DataSource::OUT_<ENAME>()\n{\n	return Output(<EID>);\n}\n\n'
        eventfndef = eventfndef.replace(/<SMNAME>/g, self.smname);
        for (i = 0; i != self.eventNames.length; i += 1) {
            self.eventfndecl += self.headerspaces + 'void OUT_' + self.eventNames[i] + '();\n'
            var eventcode = eventfndef.slice(0);
            eventcode = eventfndef.replace(/<ENAME>/g, self.eventNames[i]);
            eventcode = eventcode.replace(/<EID>/g, self.eventsID[self.eventNames[i]].toString());
            self.eventfndef += eventcode;
        }

        self.logger.debug('event decl ' + self.eventfndecl);
        self.logger.debug('event def ' + self.eventfndef);

        self.headercode = self.headercode.replace('<EVENT_FN_DECL>', self.eventfndecl);
        self.sourcecode = self.sourcecode.replace('<EVENT_FN_DEF>', self.eventfndef);

    };



    SMCodeGen.prototype.generateVariableCode = function () {
        var self = this;
        var i = 0;


        self.variableNames.sort();
        for (i = 0; i != self.variableNames.length; i += 1) {
            var varnode = self.variables[self.variableNames[i]];
            var vartype = self.core.getAttribute(varnode, 'Type');
            self.vardecl += self.headerspaces + vartype + ' ' + self.variableNames[i] + ';\n';
        }
        self.headercode = self.headercode.replace('<VAR_DECL>', self.vardecl);


    };

    SMCodeGen.prototype.storeState = function (nodeObject) {
        var self = this;
        var snodePath = self.core.getPath(nodeObject);
        self.states[snodePath] = nodeObject;
        self.statesID[self.stateCounter] = nodeObject;
        self.statesPathToID[snodePath] = self.stateCounter;
        self.stateCounter += 1;
        return (self.stateCounter - 1);
    }

    SMCodeGen.prototype.getStateID = function (nodeObject) {
        var self = this;
        var snodePath = self.core.getPath(nodeObject);
        return self.statesPathToID[snodePath];
    }

    SMCodeGen.prototype.getTransitionID = function (nodeObject) {
        var self = this;
        self.transCounter += 1;
        return (self.transCounter - 1);
    }

    SMCodeGen.prototype.checkInitialState = function (nodeObject) {
        var self = this;
        var i = 0;
        var dstconns = self.core.getCollectionPaths(nodeObject, 'dst');

        for (i = 0; i < dstconns.length; i += 1) {
            var connnode = self.nodes[dstconns[i]];
            if (!connnode)
                continue;
            var srcPath = self.core.getPointerPath(connnode, 'src');
            if (!srcPath)
                continue;
            var srcNode = self.nodes[srcPath];
            if (!srcNode)
                continue;
            if (self.isMetaTypeOf(srcNode, self.META.Initial)) {
                return true;
            }
        }
        return false;
    };


    SMCodeGen.prototype.generateStateCode = function (nodeObject, parent, psid, numchildstates, statecount) {
        var self = this;
        var sid = self.storeState(nodeObject);
        var ptype = self.core.getAttribute(parent, 'Decomposition');
        var pname = self.core.getAttribute(parent, 'name');
        var stype = self.core.getAttribute(nodeObject, 'Decomposition');
        var scodetype = 'STATEMACHINE::AND';
        if (stype == 'OR') {
            scodetype = 'STATEMACHINE::OR';
        }

        var sname = self.core.getAttribute(nodeObject, 'name');

        var sduring = self.core.getAttribute(nodeObject, 'ActionDuring');
        var sentry = self.core.getAttribute(nodeObject, 'ActionOnEntry');
        var sexit = self.core.getAttribute(nodeObject, 'ActionOnExit');

        var isinitial = false;
        var gencode = '';

        if (ptype == 'OR' && numchildstates == 1) {
            isinitial = true;
        }

        if (ptype == 'AND') {
            isinitial = true;

        }

        if (!isinitial && ptype == 'OR') {
            if (self.checkInitialState(nodeObject)) {
                isinitial = true;
            }
        }

        var isinitStr = 'false';
        if (isinitial)
            isinitStr = 'true';

        if (ptype == 'AND') {
            gencode = '	_pStateMachine->addRegion("R_' + pname + '_' + sname + '",' + statecount.toString() + ',' + psid.toString() + ');\n'
            gencode += '	_pStateMachine->addState(' + statecount.toString() + ',' + psid.toString() + ',"' + sname + '",' + scodetype + ',' + sid.toString() + ',false,' + isinitStr + ');\n'
        }
        else {
            gencode += '	_pStateMachine->addState(0,' + psid.toString() + ',"' + sname + '",' + scodetype + ',' + sid.toString() + ',false,' + isinitStr + ');\n'
        }

        if (scodetype == 'OR') {
            gencode += '	_pStateMachine->addRegion("R_' + sname + '",0,' + psid.toString() + ');\n'
        }


        //generate state code entries
        self.statesregion += gencode;

        if (sduring != '') {
            self.statesduring += '\n';
            self.statesduring += '		case ' + sid.toString() + ':{\n'
            self.statesduring += '		' + sduring + ';\n';
            self.statesduring += '		return;\n';
            self.statesduring += '		}\n';
        }

        if (sentry != '') {
            self.statesentry += '\n';
            self.statesentry += '		case ' + sid.toString() + ':{\n'
            self.statesentry += '		' + sentry + ';\n';
            self.statesentry += '		return;\n';
            self.statesentry += '		}\n';
        }

        if (sexit != '') {
            self.statesexit += '\n';
            self.statesexit += '		case ' + sid.toString() + ':{\n'
            self.statesexit += '		' + sexit + ';\n';
            self.statesexit += '		return;\n';
            self.statesexit += '		}\n';
        }

    };


    SMCodeGen.prototype.processStateChildren = function (nodeObject) {
        var self = this;
        var i, states, childNode;
        var psid = self.getStateID(nodeObject);
        var childList = self.core.getChildrenPaths(nodeObject);
        states = [];
        i = 0;

        for (i = 0; i < childList.length; i += 1) {
            childNode = self.nodes[childList[i]];

            if (self.isMetaTypeOf(childNode, self.META.State)) {
                self.logger.debug(' got state');
                states.push(childNode);
            }

            if (self.isMetaTypeOf(childNode, self.META.Transition)) {
                self.logger.debug(' got transition');
                self.transitions.push(childNode);
            }
        }

        for (i = 0; i < states.length; i += 1) {

            self.generateStateCode(states[i], nodeObject, psid, states.length, i);
        }

        for (i = 0; i < states.length; i += 1) {

            self.processStateChildren(states[i]);
        }

    };

    SMCodeGen.prototype.getDstState = function (nodeObject) {
        var self = this;
        var i = 0;
        if (self.connectorsTranversed.length > 0 && self.connectorsTranversed.indexOf(nodeObject) >= 0)
            return '';

        self.connectorsTraversed.push(nodeObject);

        var srcconns = self.core.getCollectionPaths(nodeObject, 'src');

        for (i = 0; i < dstconns.length; i += 1) {
            var connnode = self.nodes[srcconns[i]];
            if (!connnode)
                continue;
            if (self.isMetaTypeOf(connnode, self.META.ToState)) {
                var dstsPath = self.core.getPointerPath(connnode, 'dst');
                if (!dstPath)
                    continue;
                return dstPath;
            }
        }

        for (i = 0; i < dstconns.length; i += 1) {
            var connnode = self.nodes[srcconns[i]];
            if (!connnode)
                continue;
            if (self.isMetaTypeOf(connnode, self.META.ToConnector)) {
                var dstPath = self.core.getPointerPath(connnode, 'dst');
                if (!dstPath)
                    continue;
                var connector = self.nodes[dstPath];
                var finaldstpath = self.getDstState(connector);
                if (finaldstpath == '')
                    continue;
                else
                    return finaldstpath;
            }
        }

        return '';
    }

    SMCodeGen.prototype.generateTransitionCode = function (nodeObject) {
        var self = this;
        var srcPath = self.core.getPointerPath(nodeObject, 'src');
        var sid = self.statesPathToID[srcPath];

        var dstPath = self.core.getPointerPath(nodeObject, 'dst');
        var dstObj = self.nodes[dstPath];
        var did = -1;
        if (self.isMetaTypeOf(dstObj, self.META.State)) {
            did = self.statesPathToID[dstPath];
        }
        else {

            if (self.isMetaTypeOf(dstObj, self.META.Connector)) {
                self.connectorsTraversed = [];

                var dstStatePath = self.getDstState(dstObj);
                if (dstStatePath != '') {
                    did = self.statesPathToID[dstStatePath];
                }
                else {

                    return;
                }
            }


        }

        var tid = self.getTransitionID(nodeObject);

        var action = self.core.getAttribute(nodeObject, 'Action');
        var delay = self.core.getAttribute(nodeObject, 'Delay');
        var guard = self.core.getAttribute(nodeObject, 'Guard');
        var trigger = self.core.getAttribute(nodeObject, 'Trigger');
        var order = self.core.getAttribute(nodeObject, 'Order');


        if (action != '') {
            self.tafndecl += self.headerspaces + 'void TA_T' + tid.toString() + '();\n'
            self.tafndef += '\nvoid SM_<SMNAME>::DataSource::TA_T' + tid.toString() + '()\n{\n	' + action + '\n	return;\n}\n\n';
            self.tafnchoice += '\n';
            self.tafnchoice += '		case ' + tid.toString() + ':{ \n'
            self.tafnchoice += '		 TA_T' + tid.toString() + '();\n';
            self.tafnchoice += '		 break;\n';
            self.tafnchoice += '		}\n';
        }

        if (guard != '') {
            self.tgfndecl += self.headerspaces + 'bool TG_T' + tid.toString() + '();\n'
            self.tgfndef += '\nbool SM_<SMNAME>::DataSource::TG_T' + tid.toString() + '()\n{\n	return ' + guard + ';\n}\n\n';
            self.tgfnchoice += '\n';
            self.tgfnchoice += '		case ' + tid.toString() + ': return TG_T' + tid.toString() + '();\n';

        }

        if (trigger != '') {
            self.ttfndecl += self.headerspaces + 'bool TT_T' + tid.toString() + '();\n'
            self.ttfndef += '\nbool SM_<SMNAME>::DataSource::TT_T' + tid.toString() + '()\n{\n	return ' + trigger + ';\n}\n\n';
            self.ttfnchoice += '\n';
            self.ttfnchoice += '		case ' + tid.toString() + ': return TT_T' + tid.toString() + '();\n';

        }

        self.transcreation += '	_pStateMachine->addTransition(' + sid.toString() + ',' + did.toString() + ',' + order + ',' + tid.toString() + ',' + delay + ');\n'

    };

    SMCodeGen.prototype.generateAllTransitionCode = function (nodeObject, parent) {
        var self = this;
        var i = 0;
        for (i = 0; i < self.transitions.length; i += 1) {

            var t = self.transitions[i];
            self.generateTransitionCode(t);
        }


    };


    SMCodeGen.prototype.processTransitionChildren = function (nodeObject) {
        var self = this;
        self.core.loadChildren(nodeObject)
		.then(function (childList) {
		    var i, states;
		    for (i = 0; i < childList.length; i += 1) {

		        if (self.isMetaTypeOf(childList[i], self.META.Transition)) {
		            self.transitions.push(childList[i]);
		        }
		    }
		});
    };

    SMCodeGen.prototype.updateHeaderCode = function () {
        var self = this;
        self.headercode = self.headercode.replace('<TG_FN_DECL>', self.tgfndecl);
        self.headercode = self.headercode.replace('<TA_FN_DECL>', self.tafndecl);
        self.headercode = self.headercode.replace('<TT_FN_DECL>', self.ttfndecl);
    };

    SMCodeGen.prototype.updateSourceCode = function () {
        var self = this;
        self.sourcecode = self.sourcecode.replace('<STATES_REGIONS>', self.statesregion);
        self.sourcecode = self.sourcecode.replace('<TRANSITIONS>', self.transcreation);

        self.sourcecode = self.sourcecode.replace('<TG_FN_DEF>', self.tgfndef);
        self.sourcecode = self.sourcecode.replace('<TA_FN_DEF>', self.tafndef);
        self.sourcecode = self.sourcecode.replace('<TT_FN_DEF>', self.ttfndef);

        if (self.tgfnchoice == '') {
            self.sourcecode = self.sourcecode.replace('<TG_SWITCH>', self.tgfnchoice);
        }
        else {

            var replstr = '	switch(tid)\n	{\n';
            replstr += self.tgfnchoice;
            replstr += '\n		default: break;\n';
            replstr += '	}\n';
            self.sourcecode = self.sourcecode.replace('<TG_SWITCH>', replstr);
        }

        if (self.tafnchoice == '') {
            self.sourcecode = self.sourcecode.replace('<TA_SWITCH>', self.tafnchoice);
        }
        else {

            var replstr = '	switch(tid)\n	{\n';
            replstr += self.tafnchoice;
            replstr += '\n		default: break;\n';
            replstr += '	}\n';
            self.sourcecode = self.sourcecode.replace('<TA_SWITCH>', replstr);
        }

        if (self.ttfnchoice == '') {
            self.sourcecode = self.sourcecode.replace('<TT_SWITCH>', self.ttfnchoice);
        }
        else {

            var replstr = '	switch(tid)\n	{\n';
            replstr += self.ttfnchoice;
            replstr += '\n		default: break;\n';
            replstr += '	}\n';
            self.sourcecode = self.sourcecode.replace('<TT_SWITCH>', replstr);
        }

        if (self.statesduring == '') {
            self.sourcecode = self.sourcecode.replace('<S_DURING_SWITCH>', self.statesduring);
        }
        else {

            var replstr = '	switch(sid)\n	{\n';
            replstr += self.statesduring;
            replstr += '\n		default: break;\n';
            replstr += '	}\n';
            self.sourcecode = self.sourcecode.replace('<S_DURING_SWITCH>', replstr);
        }

        if (self.statesentry == '') {
            self.sourcecode = self.sourcecode.replace('<S_ENTRY_SWITCH>', self.statesentry);
        }
        else {

            var replstr = '	switch(sid)\n	{\n';
            replstr += self.statesentry;
            replstr += '\n		default: break;\n';
            replstr += '	}\n';
            self.sourcecode = self.sourcecode.replace('<S_ENTRY_SWITCH>', replstr);
        }

        if (self.statesexit == '') {
            self.sourcecode = self.sourcecode.replace('<S_EXIT_SWITCH>', self.statesexit);
        }
        else {

            var replstr = '	switch(sid)\n	{\n';
            replstr += self.statesexit;
            replstr += '\n		default: break;\n';
            replstr += '	}\n';
            self.sourcecode = self.sourcecode.replace('<S_EXIT_SWITCH>', replstr);
        }

    };


    SMCodeGen.prototype.process = function (callback, nodeObject) {
        var self = this;

        self.core.loadSubTree(nodeObject)
		.then(function (nodeList) {
		    var i, name, nodePath;
		    self.logger.debug('loaded subtree');
		    for (i = 0; i < nodeList.length; i += 1) {
		        nodePath = self.core.getPath(nodeList[i]);
		        self.nodes[nodePath] = nodeList[i];
		        name = self.core.getAttribute(nodeList[i], 'name');
		        if (self.isMetaTypeOf(nodeList[i], self.META.Event)) {
		            self.events[name] = nodeList[i];
		            self.eventNames.push(name);
		            self.logger.debug('event ' + name);
		        }
		        //record test with hierarchical name
		        if (self.isMetaTypeOf(nodeList[i], self.META.Variable)) {
		            self.variables[name] = nodeList[i];
		            self.variableNames.push(name);
		            self.logger.debug('variables ' + name);
		        }

		    }

		    self.logger.debug('1');
		    self.generateEventCode();
		    self.logger.debug('2');
		    self.generateVariableCode();
		    self.logger.debug('3');
		    self.storeState(nodeObject);
		    self.logger.debug('4');
		    self.processStateChildren(nodeObject);
		    self.logger.debug('5');
		    //self.processTransitionChildren(nodeObject);
		    self.generateAllTransitionCode();
		    self.logger.debug('6');
		    self.updateHeaderCode();
		    self.logger.debug('7');
		    self.updateSourceCode();
		    self.logger.debug('8');
		    self.headercode = self.headercode.replace(/<SMNAME>/g, self.smname);
		    self.sourcecode = self.sourcecode.replace(/<SMNAME>/g, self.smname);

		    //save dmatrix file on server
		    var artifact = self.blobClient.createArtifact('SM_' + self.smname);

		    var files = {};
		    files['SM_' + self.smname + '.h'] = self.headercode;
		    files['SM_' + self.smname + '.cpp'] = self.sourcecode;

		    // Upload the files to server.
		    artifact.addFiles(files, function (err) {
		        if (err) {
		            callback(err, self.result);
		            return;
		        }
		        // Save the artifact (uploads meta data about the file(s) within in it).
		        artifact.save(function (err, hash) {
		            if (err) {
		                callback(err, self.result);
		                return
		            }
		            // Add a link to the artifact to the plugin-result.
		            self.result.addArtifact(hash);
		            self.result.setSuccess(true);
		            callback(null, self.result);
		        });
		    });
		});



    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    SMCodeGen.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject;

        self.updateMETA(self.metaTypes);

        if (self.core.getPath(self.activeNode) === ' ' || self.isMetaTypeOf(self.activeNode, self.META.StateMachine) === false) {
            callback('CurrentNode should be a State Machine', self.result);
            return;
        }

        self.smname = self.core.getAttribute(self.activeNode, 'name');
        self.headercode = self.headercode.replace(/<SMNAME>/g, self.smname);
        self.sourcecode = self.sourcecode.replace(/<SMNAME>/g, self.smname);
        try {
            self.process(callback, self.activeNode);

        }
        catch (e) {
            self.logger.error('error' + e);
        }




        // // First transform ejs-files into js files (needed for client-side runs) -> run Templates/combine_templates.js.
        // // See instructions in file. You must run this after any modifications to the ejs template.
        // var templateJS = ejs.render(TEMPLATES['JavaScript.js.ejs'], {a: 'a', b: 'b'});
        // var templateFileName = 'generatedFiles/subDir/JavaScript.js';
        // var artifact = self.blobClient.createArtifact('templateFiles');
        // artifact.addFile(templateFileName, templateJS, function (err) {
        // if (err) {
        // callback(err, self.result);
        // return;
        // }
        // self.blobClient.saveAllArtifacts(function (err, hashes) {
        // if (err) {
        // callback(err, self.result);
        // return;
        // }
        // // This will add a download hyperlink in the result-dialog.
        // self.result.addArtifact(hashes[0]);
        // // This will save the changes. If you don't want to save;
        // // exclude self.save and call callback directly from this scope.
        // self.save('State Machine Code Generator updated model.', function (err) {
        // if (err) {
        // callback(err, self.result);
        // return;
        // }
        // self.result.setSuccess(true);
        // callback(null, self.result);
        // });
        // });
        // });

    };

    return SMCodeGen;
});
