/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.16.0 from webgme on Thu Apr 18 2019 15:39:58 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of JSONOutput.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin JSONOutput.
     * @constructor
     */
    function JSONOutput() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
        this.jsonOutput = {};
        this.nodeData = {};
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    JSONOutput.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    JSONOutput.prototype = Object.create(PluginBase.prototype);
    JSONOutput.prototype.constructor = JSONOutput;


    JSONOutput.prototype.buildNodeData = function(path, name, metaType, basePath, parentPath, attributeNames, attributes, srcPath, dstPath){
        var self = this;
        var i =0;
        self.nodeData[path]={};
        self.nodeData[path]['Path'] = path;
        self.nodeData[path]['Name'] = name;
        self.nodeData[path]['MetaType'] = metaType;
        self.nodeData[path]['BasePath'] = basePath;
        self.nodeData[path]['BasePath'] = basePath;
        self.nodeData[path]['ParentPath']=parentPath;
        self.nodeData[path]['Attributes'] = {};
        if (srcPath && dstPath)
        {
            self.nodeData[path]['SrcPath'] = srcPath;
            self.nodeData[path]['DstPath'] = dstPath;
        }
         
        for(i=0;i!=attributeNames.length; i+=1)
        {
            self.nodeData[path]['Attributes'][attributeNames[i]] = attributes[attributeNames[i]];
        }
        
    };
    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
     */
    JSONOutput.prototype.main = function (callback) {
		var self = this;
   var activeNode = this.activeNode,
      core = this.core,
      logger = this.logger;
      
    var activenodename = self.core.getAttribute(self.activeNode, 'name');
		var dt = new Date();
		var filename = 'JSON_Output_'+activenodename+'-'+ dt.valueOf() +'.json';
	 

  function atNode(node, done) {
    try {
      var metaNode = core.getBaseType(node),
          name = core.getAttribute(node, 'name'),
          path = core.getPath(node),
          attributeNames = core.getAttributeNames(node),
          isconnection = core.isConnection(node),
          base = core.getBase(node),
          parent = core.getParent(node),
          basePath='',
          metaType='',
          srcPath='',
          dstPath='',
          attributes={},
          parentPath='',
          i;
          
          

      if (metaNode) {
        metaType = core.getAttribute(metaNode, 'name');
      } else {
        // The root-node does not have a meta node.
        metaType = 'undefined';
      }
      
      if (base){
          basePath = core.getPath(base);
      }
      
      if (parent){
          parentPath = core.getPath(parent);
      }
      
      i=0;
      attributes={};
      for(i=0; i!=attributeNames.length; i+=1)
      {
         attributes[attributeNames[i]] = core.getAttribute(node,attributeNames[i])
         
      }
      
      if (isconnection)
      {
         srcPath = self.core.getPointerPath(node, 'src');
         dstPath = self.core.getPointerPath(node, 'dst');
      }
      logger.info('[', path, '] - ', name, 'is of type', metaType);
      self.buildNodeData(path, name, metaType, basePath, parentPath, attributeNames, attributes, srcPath, dstPath);
      done();
    } catch (err) {
      done(err);
    }
  }

  core.traverse(activeNode, null, atNode, function(err){
	  if (!err)
	  {
       self.jsonOutput = JSON.stringify(self.nodeData, special_character_replacer, 2);
      var artifact = self.blobClient.createArtifact('JSONOutput');
			var content = {};
			content[filename] =  self.jsonOutput;
		    // Upload the files to server.

		    artifact.addFiles(content, function (err) {
		        if (err) {
		            callback(err, self.result);
		            return;
		        }
		        // Save the artifact (uploads meta data about the file(s) within in it).
		        artifact.save(function (err, hash) {
		            if (err) {
		                callback(err, self.result);
		                return
		            }
		            // Add a link to the artifact to the plugin-result.
		            self.result.addArtifact(hash);
		            
		        });
		    });
               
        self.result.setSuccess(true);
	  }
	  
      // A plugin should always return with a result, in iCore it's optional and
      // used only to display the plugin result dialog.
      callback(err, self.result);
  });
};

	// WebGME api returns strings with special characters already escaped (eg. "My \"string\"")
    // JSON.stringify removes these escape characters.
    // eg. "My \"string\"" becomes "My "string"", which is not valid JSON
    // Need replacer function to escape the escape characters.  (eg. "My \"string\"" -> "My \\"string\\"")
    function special_character_replacer(key, val) {
        if (typeof(val)!="string") return val;
        return val
          .replace(/[\\]/g, '\\\\')
          .replace(/[\/]/g, '\\/')
          .replace(/[\b]/g, '\\b')
          .replace(/[\f]/g, '\\f')
          .replace(/[\n]/g, '\\n')
          .replace(/[\r]/g, '\\r')
          .replace(/[\t]/g, '\\t')
          .replace(/[\"]/g, '\\"');
    }
    return JSONOutput;
});
