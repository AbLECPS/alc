/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Tue Jul 04 2017 05:13:52 GMT-0500 (Central Daylight Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'plugin/GSNReportGen/GSNReportGen/meta'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    MetaTypes) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of GSNReportGen.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin GSNReportGen.
     * @constructor
     */
    var GSNReportGen = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
        this.pluginMetadata = pluginMetadata;
		
		this.nodes={};
		this.nodesAssigned=[];
		this.nodesUnassigned=[];
		this.nodeIDs={};
		this.nodeTypes={};
		this.nodeLabels={};
		this.nodeLabelName={};
		this.nodeParents={};
		this.nodeChildren={};

		
		this.goals={};
		this.strategies={};
		this.solutions={};
		this.contexts={};
		this.assumptions={};
		this.justifications={};
		
		this.childgoals=[];
		this.childstrategies = [];
		
		this.nodesVisited=[];
		this.reportStr=[];
		
		

		
		
    };
	
	
	
	

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    GSNReportGen.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    GSNReportGen.prototype = Object.create(PluginBase.prototype);
    GSNReportGen.prototype.constructor = GSNReportGen;
	
	GSNReportGen.prototype.generateReportHeader = function (name) {
		this.reportStr.push('<!DOCTYPE html>');
		this.reportStr.push('<html>');
		this.reportStr.push('<title>');
		this.reportStr.push('GSN Report :'+name);
		this.reportStr.push('</title>');
		this.reportStr.push('<body>');
		this.reportStr.push('<p><h3><u>GSN Report : '+name+'</u></h3><p>');
		this.reportStr.push('<table style=\"width:100%\">');
		this.reportStr.push('<col width="150">');
	}
	
	GSNReportGen.prototype.getParentNodes = function (connNodes) {
	    var self = this, i,j;
		var srcNodes=[];
		if (!self.core)
		{
			self.logger.debug('nul core');
			return srcNodes;
		}
		for (i = 0; i < connNodes.length; i += 1) {
			var connnode= self.nodes[connNodes[i]];
			if (!connnode)
				continue;
			var srcPath = self.core.getPointerPath(connnode,'src');
			if (!srcPath)
				continue;
			var srcNode=self.nodes[srcPath];
			if (!srcNode)
				continue;
			if (self.isMetaTypeOf(srcNode,self.META.SupportRef))
			{
				var srcPathRef = self.core.getPointerPath(srcNode,'Ref');
				if (srcPathRef)
				{
					var srcRef = self.nodes[srcPathRef];
					if (srcRef)
					{
						srcNodes.push(srcPathRef);
					}
				}
				
			}
			else
				srcNodes.push(srcPath);
			
		}
		return srcNodes;
	};
	
	GSNReportGen.prototype.getChildNodes = function (connNodes) {
	    var self = this, i,j;
		var dstNodes=[];
		if (!self.core)
		{
			self.logger.debug('nul core');
			return dstNodes;
		}
		for (i = 0; i < connNodes.length; i += 1) {
			var connnode= self.nodes[connNodes[i]];
			if (!connnode)
				continue;
			var dstPath = self.core.getPointerPath(connnode,'dst');
			if (!dstPath)
				continue;
			var dstNode=self.nodes[dstPath];
			if (!dstNode)
				continue;
			if (self.isMetaTypeOf(dstNode,self.META.SupportRef))
			{
				var dstPathRef = self.core.getPointerPath(dstNode,'Ref');
				if (dstPathRef)
				{
					var dstRef = self.nodes[dstPathRef];
					if (dstRef)
					{
						dstNodes.push(dstPathRef);
					}
				}
				
			}
			else if (self.isMetaTypeOf(dstNode,self.META.InContextRef))
			{
				var dstPathRef = self.core.getPointerPath(dstNode,'Ref');
				if (dstPathRef)
				{
					var dstRef = self.nodes[dstPathRef];
					if (dstRef)
					{
						dstNodes.push(dstPathRef);
					}
				}
				
			}
			else
				dstNodes.push(dstPath);
			
		}
		return dstNodes;
	};
	
	GSNReportGen.prototype.printAnchorLabel = function (labelname, label) {
		var self = this;
		self.reportStr.push('<tr><td><a name=\"'+label+'\"><b><u>'+labelname+'</u></b></a></td></tr>');
		self.logger.debug(labelname + ' -> '+label);
	};
	
	GSNReportGen.prototype.printLabel = function (labelname, label) {
		var self = this;
		self.reportStr.push('<a href=\"#'+label+'\">'+labelname+'</a>');
		self.logger.debug(labelname + ' -> '+label);
	};
	
	GSNReportGen.prototype.printDescription = function (description) {
		var self = this;
		self.reportStr.push('<tr><td> Description: </td>');
		self.reportStr.push('<td>'+description+'</td></tr>');
		self.logger.debug('description : '+description);
	};
	
	GSNReportGen.prototype.printField = function (field,value) {
		var self = this;
		self.reportStr.push('<tr><td> '+field+': </td>');
		self.reportStr.push('<td>'+value+'</td></tr>');
		
	};
	
	GSNReportGen.prototype.printEndofBlock = function () {
		var self = this;
		self.reportStr.push('<tr height = 20px></tr>');
		
		
	};
	
	
	
	GSNReportGen.prototype.printContextLabels = function (nodes) {
		var self = this;
		var i,nodePath;
		var labels = [];
		for (i=0; i<nodes.length; i++)
		{
			nodePath = nodes[i];
			if (self.nodeTypes[nodePath] =='context')
			{
				labels.push(nodePath);
			}
		
		}
		if (labels.length ==0)
			return;
		self.logger.debug('Context : ');
		self.reportStr.push('<tr> <td> Context:  </td>');
		self.reportStr.push('<td>');
		for(i=0; i<labels.length; i++)
		{
			nodePath = labels[i];
			var labelname= self.nodeLabelName[nodePath];
			var label=self.nodeLabels[nodePath];
			
			self.logger.debug(labelname + '   '+ label);
			self.printLabel(labelname,label);
			
		}
		self.reportStr.push('</td></tr>');
	};
	
	GSNReportGen.prototype.printAssumptionLabels = function (nodes) {
		var self = this;
		var i,nodePath;
		var labels = [];
		for (i=0; i<nodes.length; i++)
		{
			nodePath = nodes[i];
			if (self.nodeTypes[nodePath] =='assumption')
			{
				labels.push(nodePath);
			}
		
		}
		if (labels.length ==0)
			return;
		self.logger.debug('Assumption : ');
		self.reportStr.push('<tr> <td> Assumption:  </td>');
		self.reportStr.push('<td>');
		for(i=0; i<labels.length; i++)
		{
			nodePath = labels[i];
			var labelname= self.nodeLabelName[nodePath];
			var label=self.nodeLabels[nodePath];
			
			self.logger.debug(labelname + '   '+ label);
			
			self.printLabel(labelname,label);
			
		}
		self.reportStr.push('</td></tr>');
	};
	
	GSNReportGen.prototype.printJustificationLabels = function (nodes) {
		var self = this;
		var i,nodePath;
		var labels = [];
		for (i=0; i<nodes.length; i++)
		{
			nodePath = nodes[i];
			if (self.nodeTypes[nodePath] =='justification')
			{
				labels.push(nodePath);
			}
		
		}
		if (labels.length ==0)
			return;
		self.logger.debug('Justification : ');
		self.reportStr.push('<tr> <td> Justification:  </td>');
		self.reportStr.push('<td>');
		for(i=0; i<labels.length; i++)
		{
			nodePath = labels[i];
			var labelname= self.nodeLabelName[nodePath];
			var label=self.nodeLabels[nodePath];
			
			self.logger.debug(labelname + '   '+ label);
			
			self.printLabel(labelname,label);
			
		}
		self.reportStr.push('</td></tr>');
	};
	
	GSNReportGen.prototype.printSolutionLabels = function (nodes) {
		var self = this;
		var i,nodePath;
		var labels = [];
		for (i=0; i<nodes.length; i++)
		{
			nodePath = nodes[i];
			if (self.nodeTypes[nodePath] =='solution')
			{
				labels.push(nodePath);
			}
		
		}
		if (labels.length ==0)
			return;
		self.logger.debug('Solution : ');
		self.reportStr.push('<tr> <td> Solution:  </td>');
		self.reportStr.push('<td>');
		for(i=0; i<labels.length; i++)
		{
			nodePath = labels[i];
			var labelname= self.nodeLabelName[nodePath];
			var label=self.nodeLabels[nodePath];
			
			self.logger.debug(labelname + '   '+ label);
			
			self.printLabel(labelname,label);
			
		}
		self.reportStr.push('</td></tr>');
	};
	
	GSNReportGen.prototype.printParentLabels = function (nodes) {
		var self = this;
		var i,j,nodePath;
		var labels = [];
		var choicenodes = [];
		
		
		for (i=0; i<nodes.length; i++)
		{
			nodePath = nodes[i];
			if (self.nodeTypes[nodePath] =='strategy' || self.nodeTypes[nodePath] =='goal')
			{
				labels.push(nodePath);
			}
			if (self.nodeTypes[nodePath] =='choice')
			{
				choicenodes.push(nodePath);
			}
		
		}
		
		for (i=0; i<choicenodes.length; i++)
		{
			nodePath = choicenodes[i];
			var cchildren = self.nodeParents[nodePath];
			//get m, n for nodepath
			var choicenode = self.nodes[nodePath];
			
			
			
			for(j=0; j<cchildren.length; j++)
			{
				var cpath=cchildren[j];
				if (self.nodeTypes[cpath] =='strategy' || self.nodeTypes[cpath] =='goal')
				{
					labels.push(cpath);
				}
			
			}
		
		}
		if (labels.length ==0)
			return;
		self.logger.debug('Parent nodes : ');
		self.reportStr.push('<tr> <td> Parent Nodes:  </td>');
		self.reportStr.push('<td>');
		for(i=0; i<labels.length; i++)
		{
			nodePath = labels[i];
			var labelname= self.nodeLabelName[nodePath];
			var label=self.nodeLabels[nodePath];
			
			self.logger.debug(labelname + ' p  '+ label);
			
			self.printLabel(labelname,label);
			
		}
		self.reportStr.push('</td></tr>');
	};
	
	
	
	GSNReportGen.prototype.printChildLabels = function (nodes) {
		var self = this;
		var i,j,nodePath;
		var labels = [];
		var choicenodes = [];
		var m = '';
		var mstr= 'All';
		
		
		for (i=0; i<nodes.length; i++)
		{
			nodePath = nodes[i];
			if (self.nodeTypes[nodePath] =='strategy' || self.nodeTypes[nodePath] =='goal')
			{
				labels.push(nodePath);
			}
			if (self.nodeTypes[nodePath] =='choice')
			{
				choicenodes.push(nodePath);
			}
		
		}
		
		for (i=0; i<choicenodes.length; i++)
		{
			nodePath = choicenodes[i];
			var cchildren = self.nodeChildren[nodePath];
			//get m, n for nodepath
			var choicenode = self.nodes[nodePath];
			m = self.core.getAttribute(choicenode,'Minimum Required');
			
			
			for(j=0; j<cchildren.length; j++)
			{
				var cpath=cchildren[j];
				if (self.nodeTypes[cpath] =='strategy' || self.nodeTypes[cpath] =='goal')
				{
					labels.push(cpath);
				}
			
			}
		
		}
		if (labels.length ==0)
			return;
		self.logger.debug('Child nodes : ');
		self.reportStr.push('<tr> <td> Child Nodes:  </td>');
		if (m != '')
		{
			
			if (m==1)
			{
				mstr='Any One';
			}
			else if (m >1)
			{
				mstr= 'Atleast '+m +' required';
			}
			self.logger.debug( ' Choice: ' + m );
			self.reportStr.push('<td> Choice: '+ mstr );
		}
		else
			self.reportStr.push('<td>');
		for(i=0; i<labels.length; i++)
		{
			nodePath = labels[i];
			var labelname= self.nodeLabelName[nodePath];
			var label=self.nodeLabels[nodePath];
			
			self.logger.debug(labelname + ' c '+ label);
			
			self.printLabel(labelname,label);
			
			if (self.nodeTypes[nodePath] =='goal')
			{
				if (self.nodesVisited.indexOf(nodePath)==-1)
					self.childgoals.push(nodePath);
			}
			else if (self.nodeTypes[nodePath] =='strategy')
			{
				if (self.nodesVisited.indexOf(nodePath)==-1)
					self.childstrategies.push(nodePath);
			}
		}
		self.reportStr.push('</td></tr>');
	};
	
	
	GSNReportGen.prototype.printGoal = function (nodePath) {
     var self = this;
	 var nodeObject = self.nodes[nodePath];
	 
	 if (self.nodesVisited.indexOf(nodePath)>=0)
		return;
	
	self.nodesVisited.push(nodePath);
	
	//print goal id with label
	var name = self.nodeLabelName[nodePath];
	var label = self.nodeLabels[nodePath];
	var status = self.core.getAttribute(nodeObject, 'In Development'), 
		assignedto = self.core.getAttribute(nodeObject, 'Assigned To'),
		reviewedby = self.core.getAttribute(nodeObject, 'Reviewed By'),
		description = self.core.getAttribute(nodeObject, 'description');
	
	var parentnodes = self.nodeParents[nodePath];
	var childnodes = self.nodeChildren[nodePath];
	self.printAnchorLabel(name,label);
	var statusStr= 'In Development';
	if (!status)
		statusStr = 'Completed';
	self.logger.debug(' Assigned To: '+assignedto);	
	self.logger.debug(' Reviewer : '+reviewedby);
	self.logger.debug(' Status: '+statusStr);
	
	self.printField('Assigned To' , assignedto);
	self.printField('Reviewer' , reviewedby);
	self.printField('Status' , statusStr);
	
	self.printDescription(description);
	self.printParentLabels(parentnodes);
	self.printAssumptionLabels(childnodes);
	self.printContextLabels(childnodes);
	self.printJustificationLabels(childnodes);
	self.printChildLabels(childnodes);
	self.printSolutionLabels(childnodes);
	self.printEndofBlock();
	
	
	
   };
	
	GSNReportGen.prototype.printStrategy = function (nodePath) {
	 var self = this;
	 var nodeObject = self.nodes[nodePath];
	 
	 if (self.nodesVisited.indexOf(nodePath)>=0)
		return;
	self.nodesVisited.push(nodePath);	
	var name = self.nodeLabelName[nodePath];
	var label = self.nodeLabels[nodePath];
	var description = self.core.getAttribute(nodeObject, 'description');
	var parentnodes = self.nodeParents[nodePath];
	var childnodes = self.nodeChildren[nodePath];
	
	self.printAnchorLabel(name,label);
	self.printDescription(description);
	self.printParentLabels(parentnodes);
	self.printAssumptionLabels(childnodes);
	self.printContextLabels(childnodes);
	self.printJustificationLabels(childnodes);
	self.printChildLabels(childnodes);
	self.printSolutionLabels(childnodes);
	self.printEndofBlock();
	
	
	
	};

	GSNReportGen.prototype.printSolution = function (nodePath) {
	 var self = this;
	 var nodeObject = self.nodes[nodePath];
	 
	 if (self.nodesVisited.indexOf(nodePath)>=0)
		return;
		
	var name = self.nodeLabelName[nodePath];
	var label = self.nodeLabels[nodePath];
	var description = self.core.getAttribute(nodeObject, 'description');
	
	var parentnodes = self.nodeParents[nodePath];
	var childnodes = self.nodeChildren[nodePath];
	self.nodesVisited.push(nodePath);
	self.printAnchorLabel(name,label);
	self.printDescription(description);
	self.printParentLabels(parentnodes);
	self.printAssumptionLabels(childnodes);
	self.printContextLabels(childnodes);
	self.printJustificationLabels(childnodes);
	self.printEndofBlock();
	
	};
	
	GSNReportGen.prototype.printAssumption = function (nodePath) {
	 var self = this;
	 var nodeObject = self.nodes[nodePath];
	 
	 if (self.nodesVisited.indexOf(nodePath)>=0)
		return;
	self.nodesVisited.push(nodePath);	
	var name = self.nodeLabelName[nodePath];
	var label = self.nodeLabels[nodePath];
	var description = self.core.getAttribute(nodeObject, 'description');
	
	var parentnodes = self.nodeParents[nodePath];
	
	
	self.printAnchorLabel(name,label);
	self.printDescription(description);
	self.printParentLabels(parentnodes);
	self.printEndofBlock();
	
	};
	
	GSNReportGen.prototype.printContext = function (nodePath) {
	 var self = this;
	 var nodeObject = self.nodes[nodePath];
	 
	 if (self.nodesVisited.indexOf(nodePath)>=0)
		return;
	
	self.nodesVisited.push(nodePath);	
	var name = self.nodeLabelName[nodePath];
	var label = self.nodeLabels[nodePath];
	var description = self.core.getAttribute(nodeObject, 'description');
	var parentnodes = self.nodeParents[nodePath];
	
	
	self.printAnchorLabel(name,label);
	self.printDescription(description);
	self.printParentLabels(parentnodes);
	self.printEndofBlock();
	
	};
	
	
	GSNReportGen.prototype.printJustification = function (nodePath) {
	 var self = this;
	 var nodeObject = self.nodes[nodePath];
	 
	 if (self.nodesVisited.indexOf(nodePath)>=0)
		return;
	
	self.nodesVisited.push(nodePath);	
	var name = self.nodeLabelName[nodePath];
	var label = self.nodeLabels[nodePath];
	
	var description = self.core.getAttribute(nodeObject, 'description');
	
	var parentnodes = self.nodeParents[nodePath];
	
	self.printAnchorLabel(name,label);
	self.printDescription(description);
	self.printParentLabels(parentnodes);
	self.printEndofBlock();
	
	};
	
	GSNReportGen.prototype.visitChildGoals = function () {
		var self = this;
		var goals = self.childgoals.slice(0);
		self.childgoals=[];
		var i;
		for(i=0; i<goals.length; i++)
		{
			self.printGoal(goals[i]);
		}
	
	};
	
	GSNReportGen.prototype.visitChildStrategies = function () {
		var self=this;
		var strategies = self.childstrategies.slice(0);
		self.childstrategies =[];
		
		var i;
		for(i=0; i<strategies.length; i++)
		{
			self.printStrategy(strategies[i]);
		}
	
	};
	
	
	
	GSNReportGen.prototype.visitNode = function (nodePath,nodeObject) {
		var self = this;
		var id;
		var name=self.core.getAttribute(nodeObject,'name');
		id =  self.core.getAttribute(nodeObject, 'gsnid');
		self.logger.debug('id for ' + name  + ' = '+ id);
		if (id=='')
			this.nodesUnassigned.push(nodePath);
		
		this.nodesAssigned.push(nodePath);
		
		this.nodeIDs[nodePath] = id;
		this.nodeParents[nodePath] = [];
		this.nodeChildren[nodePath] = [];
		this.nodeTypes[nodePath]='';
		
		
		
		if (self.isMetaTypeOf(nodeObject,self.META.Goal))
		{
			this.nodeTypes[nodePath] ='goal';
			this.nodeLabels[nodePath]=this.nodeTypes[nodePath]+'-'+id;
			this.nodeLabelName[nodePath] = 'Goal '+id;
			self.goals[id] = nodePath;
			self.logger.debug('finished goal ');
			return;
		}
		
		if (self.isMetaTypeOf(nodeObject,self.META.Strategy))
		{
			this.nodeTypes[nodePath] ='strategy';
			this.nodeLabels[nodePath]=this.nodeTypes[nodePath]+'-'+id;
			this.nodeLabelName[nodePath] = 'Strategy '+id;
			self.strategies[id] = nodePath;
			self.logger.debug('finished strategy ');
			return;
		}
		
		if (self.isMetaTypeOf(nodeObject,self.META.Solution))
		{
			this.nodeTypes[nodePath] ='solution';
			this.nodeLabels[nodePath]=this.nodeTypes[nodePath]+'-'+id;
			this.nodeLabelName[nodePath] = 'Solution '+id;
			self.solutions[id] = nodePath;
			return;
		}
		if (self.isMetaTypeOf(nodeObject,self.META.Context))
		{
			this.nodeTypes[nodePath] ='context';
			this.nodeLabels[nodePath]=this.nodeTypes[nodePath]+'-'+id;
			this.nodeLabelName[nodePath] = 'Context '+id;
			self.contexts[id] = nodePath;
			return;
		}
		if (self.isMetaTypeOf(nodeObject,self.META.Assumption))
		{
			this.nodeTypes[nodePath] ='assumption';
			this.nodeLabels[nodePath]=this.nodeTypes[nodePath]+'-'+id;
			this.nodeLabelName[nodePath] = 'Assumption '+id;
			self.assumptions[id] = nodePath;
			return;
		}
		if (self.isMetaTypeOf(nodeObject,self.META.Justification))
		{
			this.nodeTypes[nodePath] ='justification';
			this.nodeLabels[nodePath]=this.nodeTypes[nodePath]+'-'+id;
			this.nodeLabelName[nodePath] = 'Justification '+id;
			self.justifications[id] = nodePath;
			return;
		}
   };
   
   GSNReportGen.prototype.naturalCompare = function (a, b)  {
   
		var ax = [], bx = [];

		a.replace(/(\d+)|(\D+)/g, function(_, $1, $2) { ax.push([$1 || Infinity, $2 || ""]) });
		b.replace(/(\d+)|(\D+)/g, function(_, $1, $2) { bx.push([$1 || Infinity, $2 || ""]) });
		
		while(ax.length && bx.length) {
			var an = ax.shift();
			var bn = bx.shift();
			var nn = (an[0] - bn[0]) || an[1].localeCompare(bn[1]);
			if(nn) return nn;
		}

		return ax.length - bx.length;
	}
   
   
	GSNReportGen.prototype.process = function (callback,nodeObject) {
        var self = this;
		var rootname=self.core.getAttribute(nodeObject,'name');
		var filename='GSNReport_'+rootname;
		self.core.loadSubTree(nodeObject)
		.then(function(nodeList) {
			var i,
			    j,
				nodePath,
				keylen,
				index,
				supportrefs = [],
				contextrefs = [],
				choicejns   = [] ;
			self.logger.debug('0 '+nodeList.length);
			
			for (i = 0; i < nodeList.length; i += 1) {
				 nodePath = self.core.getPath(nodeList[i]);
				 self.nodes[nodePath] = nodeList[i];
				 self.logger.debug('n' +i);
				if (self.isMetaTypeOf(nodeList[i],self.META.SupportRef))
				{
					self.nodeTypes[nodePath]='sr';
					supportrefs.push(nodePath);
				}
				else if (self.isMetaTypeOf(nodeList[i],self.META.InContextRef))
				{
					self.nodeTypes[nodePath]='cr';
					contextrefs.push(nodePath);
				}
				else if (self.isMetaTypeOf(nodeList[i],self.META.ChoiceJn))
				{
					self.nodeTypes[nodePath]='choice';
					self.nodeParents[nodePath]=[];
					self.nodeChildren[nodePath]=[];
					choicejns.push(nodePath);
				}
				else if (self.isMetaTypeOf(nodeList[i],self.META.Goal) || self.isMetaTypeOf(nodeList[i],self.META.Strategy) || self.isMetaTypeOf(nodeList[i],self.META.Solution) )
				{
					
					self.visitNode(nodePath,nodeList[i]);
				}
				else if ( self.isMetaTypeOf(nodeList[i],self.META.Context) || self.isMetaTypeOf(nodeList[i],self.META.Assumption) || self.isMetaTypeOf(nodeList[i],self.META.Justification))
				{
					self.visitNode(nodePath,nodeList[i]);
				}
			}
			
			if (self.nodesUnassigned.length > 0)
			{
				self.logger.debug('GSN Report Generator - certain nodes have not been assigned id. please assign ids or run the idgen plugin.');
				self.save('GSN Report Generator - certain nodes have not been assigned id. please assign ids or run the idgen plugin.')
				.then(function () {
					self.createMessage(self.activeNode,'GSN Report Generator - certain nodes have not been assigned id. please assign ids or run the idgen plugin.','error');
					self.result.setSuccess(false);
					callback('GSN Report Generator - certain nodes have not been assigned id. please assign ids or run the idgen plugin.', self.result);
				})
				.catch(function (err) {
					// Result success is false at invocation.
					callback(err, self.result);
				});
				
				return;
			}
			
			self.generateReportHeader(rootname);
			
			for (i = 0; i < self.nodesAssigned.length; i += 1) {
			
				var nodePath = self.nodesAssigned[i];
				var node = self.nodes[nodePath];
				var connNodesParent=self.core.getCollectionPaths(node, 'dst');
				var connNodesChild=self.core.getCollectionPaths(node, 'src');
				if (node)
				{
						var p = self.getParentNodes(connNodesParent);
						var c = self.getChildNodes(connNodesChild);
						for(j=0; j<p.length;j++)
						{
							self.nodeParents[nodePath].push(p[j]);
						}
						for(j=0; j<c.length;j++)
						{
							self.nodeChildren[nodePath].push(c[j]);
						}
					
				}
					
			}
			
			for (i = 0; i < choicejns.length; i += 1) {
			
				var nodePath = choicejns[i];
				var node = self.nodes[nodePath];
				var connNodesParent=self.core.getCollectionPaths(node, 'dst');
				var connNodesChild=self.core.getCollectionPaths(node, 'src');
				if (node)
				{
						var p = self.getParentNodes(connNodesParent);
						var c = self.getChildNodes(connNodesChild);
						for(j=0; j<p.length;j++)
						{
							self.nodeParents[nodePath].push(p[j]);
						}
						for(j=0; j<c.length;j++)
						{
							self.nodeChildren[nodePath].push(c[j]);
						}
					
				}
					
			}
			
			
			
			for (i = 0; i < supportrefs.length; i += 1) {
			
				var node = self.nodes[supportrefs[i]];
				var connNodesParent=self.core.getCollectionPaths(node, 'dst');
				var connNodesChild=self.core.getCollectionPaths(node, 'src');
				
				var dstPathRef = self.core.getPointerPath(node,'Ref');
				if (dstPathRef)
				{
					var dstRef = self.nodes[dstPathRef];
					if (dstRef)
					{
							var p = self.getParentNodes(connNodesParent);
							var c = self.getChildNodes(connNodesChild);
							for(j=0; j<p.length;j++)
							{
								self.nodeParents[dstPathRef].push(p[j]);
							}
							for(j=0; j<c.length;j++)
							{
								self.nodeChildren[dstPathRef].push(c[j]);
							}
					}
				}
					
			}
			
			for (i = 0; i < contextrefs.length; i += 1) {
			
				var node = self.nodes[contextrefs[i]];
				var connNodesParent=self.core.getCollectionPaths(node, 'dst');
				var connNodesChild=self.core.getCollectionPaths(node, 'src');
				
				var dstPathRef = self.core.getPointerPath(node,'Ref');
				if (dstPathRef)
				{
					var dstRef = self.nodes[dstPathRef];
					if (dstRef)
					{
							var p = self.getParentNodes(connNodesParent);
							
							for(j=0; j<p.length;j++)
							{
								self.nodeParents[dstPathRef].push(p[j]);
							}
							
					}
				}
					
			}
			
			var gkeys = Object.keys(self.goals);
			gkeys = gkeys.sort(self.naturalCompare);
			keylen = gkeys.length;
			/*
			This one generates the goals and strategies as you see in the tree hierarchy.
			for(i=0; i <keylen; i++)
			{
				index=gkeys[i];
				var nodePath = self.goals[index];
				var parentnodes = self.nodeParents[nodePath];
				if (parentnodes.length == 0)
				{
					self.printGoal(nodePath);
					while (true)
					{
						self.visitChildStrategies();
						self.visitChildGoals();
						if (self.childgoals.length>0 || self.childstrategies.length>0)
						{
							continue;
						}
						break;
					}
				}
			}
			*/
			
			//This one lists the goals  as per thier ids.
			for(i=0; i <keylen; i++)
			{
				index=gkeys[i];
				var nodePath = self.goals[index];
				if (self.nodesVisited.indexOf(nodePath)>=0)
					continue;
				self.printGoal(nodePath);
			}
			
			
				
			//This one lists the strategies  as per thier ids.
			var stkeys = Object.keys(self.strategies);
			stkeys = stkeys.sort(self.naturalCompare);
			keylen = stkeys.length;
			for(i=0; i <keylen; i++)
			{
				index=stkeys[i];
				var nodePath = self.strategies[index];
				if (self.nodesVisited.indexOf(nodePath)>=0)
					continue;
				self.printStrategy(nodePath);
			}
			
			var skeys = Object.keys(self.solutions);
			skeys = skeys.sort(self.naturalCompare);
			keylen = skeys.length;
			for(i=0; i <keylen; i++)
			{
				index=skeys[i];
				var nodePath = self.solutions[index];
				if (self.nodesVisited.indexOf(nodePath)>=0)
					continue;
				self.printSolution(nodePath);
			}
			
			var akeys = Object.keys(self.assumptions);
			akeys = akeys.sort(self.naturalCompare);
			keylen = akeys.length;
			for(i=0; i <keylen; i++)
			{
				index=akeys[i];
				var nodePath = self.assumptions[index];
				if (self.nodesVisited.indexOf(nodePath)>=0)
					continue;
				self.printAssumption(nodePath);
			}
			
			var ckeys = Object.keys(self.contexts);
			ckeys = ckeys.sort(self.naturalCompare);
			keylen = ckeys.length;
			for(i=0; i <keylen; i++)
			{
				index=ckeys[i];
				var nodePath = self.contexts[index];
				if (self.nodesVisited.indexOf(nodePath)>=0)
					continue;
				self.printContext(nodePath);
			}
			
			var jkeys = Object.keys(self.justifications);
			jkeys = jkeys.sort(self.naturalCompare);
			keylen = jkeys.length;
			for(i=0; i <keylen; i++)
			{
				index=jkeys[i];
				var nodePath = self.justifications[index];
				if (self.nodesVisited.indexOf(nodePath)>=0)
					continue;
				self.printJustification(nodePath);
			}
			


			
			self.reportStr.push('</table>');
			self.reportStr.push('</body>');
			self.reportStr.push('</html>');
			
			var report = self.reportStr.join('\n');
			var reportDict = {};
			
			reportDict[filename+'.html'] = report;
			
			

		    //save dmatrix file on server
		    var artifact = self.blobClient.createArtifact(filename);
		    // Upload the files to server.

		    artifact.addFiles(reportDict, function (err) {
		        if (err) {
		            callback(err, self.result);
		            return;
		        }
		        // Save the artifact (uploads meta data about the file(s) within in it).
		        artifact.save(function (err, hash) {
		            if (err) {
		                callback(err, self.result);
		                return
		            }
		            // Add a link to the artifact to the plugin-result.
		            self.result.addArtifact(hash);
		           // self.result.setSuccess(true);
		            //callback(null, self.result);
		        });
				
			self.save('GSN Report Generator Finished.')
            .then(function () {
				self.createMessage(self.activeNode,'GSN Report Generator Finished. Extract the zip file and open the report (html)','info');
                self.result.setSuccess(true);
                callback('GSN Report Generator Finished.', self.result);
            })
            .catch(function (err) {
                // Result success is false at invocation.
                callback(err, self.result);
            });
		    });
			
			
			
			
		});
	};

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    GSNReportGen.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject;

        self.updateMETA(self.metaTypes);

        // Using the logger.
        self.logger.debug('This is a debug message.');
        
        // Using the coreAPI to make changes.
		
		nodeObject = self.activeNode;
		if (self.core.getPath(self.activeNode) === ' ' || self.isMetaTypeOf(self.activeNode, self.META.GSN_Model) === false)
        {
            callback('ActiveNode is not a GSN_Model', self.result);
            return;
        }
		
		try {
		 
			self.process(callback,nodeObject);
			
				
        } catch (e) {
				//self.logger.debug('GSN Report Generator: Error '+e);
				callback(e,self.result);
        }
		

        

        // This will save the changes. If you don't want to save;
        // exclude self.save and call callback directly from this scope.
        

    };

    return GSNReportGen;
});
