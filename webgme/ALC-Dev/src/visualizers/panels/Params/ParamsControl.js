/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri Feb 23 2018 11:40:01 GMT-0600 (Central Standard Time).
 */

define(['js/Constants',
    'js/Utils/GMEConcepts',
    'js/NodePropertyNames'
], function (CONSTANTS,
             GMEConcepts,
             nodePropertyNames) {

    'use strict';

    var ParamsControl;

    ParamsControl = function (options) {

        this._logger = options.logger.fork('Control');

        this._client = options.client;

        // Initialize core collections and variables
        this._widget = options.widget;

        this._attributes = [];
        this._attributesCompare = JSON.stringify(this._attributes);
        this._currentNodeId = null;
        this._currentNodeParentId = null;
        this.parentFoldersVisited = 0;
        this.nodesToVisit = {};
        this.paramBlockID = '';
        this.rosInfoId = '';
        this._initWidgetEventHandlers();
        this._logger.debug('ctor finished');
    };
    ParamsControl.prototype.getBaseId = function (nodeObj, metaname) {
        var self = this;
        var client = this._client;
        var cids = nodeObj.getValidChildrenIds();
        var i =0;
        var cid = '';
        var node = ''
        var nodename ='';
        for(i=0; i!=cids.length; i+=1)
        {
            cid = cids[i];
            node = client.getNode(cid);
            nodename = node.getAttribute('name');
            if (nodename == metaname)
            {
                return cid;
            }

        }

        return '';

    };

    ParamsControl.prototype._initWidgetEventHandlers = function () {
        var self = this;
        var client = this._client;

        this._widget.addNewAttribute = (name, value, type) => {
            //const attrName = `${CONSTANTS.ATTR_PREFIX}${name}`;

            /*if (!attrName || attrName.indexOf('.') > 0 || attrName.indexOf('$') > 0) {
                client.notifyUser({severity: 'error', message: 'Invalid attribute name, cannot contain . or $.'});
                return;
            }*/

            if (!this.rosInfoId) {
                const nodeObj = client.getNode(self._currentNodeId);

                if (nodeObj) {

                    try {
                        var params = nodeObj.getAttribute('Definition');
                        var paramsjson = {};
                        if (params != '') {
                            paramsjson = JSON.parse(params);
                        }
                        var keys = Object.keys(paramsjson);
                        if (keys.indexOf(name) > -1) {
                            client.notifyUser({severity: 'error', message: 'Param with that name is already present'});
                            return '';

                        }
                        
                        if (value)
                        {
                            value = self.getupdatedvalue(value)
                        }
                        paramsjson[name] = value;
                        params = JSON.stringify(paramsjson);
                        var baseidtype = self.getBaseId(nodeObj, "parameter");
                        if (baseidtype)
                        {
                            client.startTransaction();
                            //var ctypes = nodeObj.getValidChildrenIds();
                            //var paramvals = {parentId: self._currentNodeId, baseId: ctypes[1]}
                            
                            
                            var paramvals = {parentId: self._currentNodeId, baseId: baseidtype}
                            var cnodeid = client.createNode(paramvals);
                            client.setAttribute(cnodeid, 'name', name);
                            client.setAttribute(self._currentNodeId, 'Definition', params);
                            client.completeTransaction();
                            return cnodeid;
                        }
                    } catch (err) {
                        this._logger.error(err);
                        client.notifyUser({severity: 'error', message: err.message});
                    }


                }
                return '';
            } else {
                const nodeObj = client.getNode(self.rosInfoId);

                if (nodeObj) {

                    try {

                        client.startTransaction();
                        var ctypes = nodeObj.getValidChildrenIds();

                        //var cMeta = self._client.getChildrenMeta(self._currentNodeId);
                        var baseMetaID = -1; 
                        var baseNode = '';
                        var i=0;
                        for (i =0; i !=ctypes.length; i++) {
                            var cMetaNode = self._client.getNode(ctypes[i]);
                            if (cMetaNode)
                            {
                                var name1 = cMetaNode.getAttribute('name');
                                if (name1.indexOf('Argument')!=-1)
                                {
                                    baseMetaID = ctypes[i];
                                    baseNode = cMetaNode;
                                    break;

                                }
                            }
                        }


                        var paramvals = {parentId: self.rosInfoId, baseId: baseMetaID}//ctypes[2]}
                        var cnodeid = client.createNode(paramvals);
                        client.setAttribute(cnodeid, 'name', name);
                        client.completeTransaction();
                        return cnodeid;
                    } catch (err) {
                        this._logger.error(err);
                        client.notifyUser({severity: 'error', message: err.message});
                    }


                }
                return '';

            }
        };

        this._widget.updateAttributeValue = (nid, name, value) => {

            if (!self.rosInfoId) {
                const nodeObj = client.getNode(self._currentNodeId);

                if (nodeObj) {

                    client.startTransaction();

                    try {
                        var params = nodeObj.getAttribute('Definition');
                        var paramsjson = {};
                        if (params.length > 0) {
                            paramsjson = JSON.parse(params);
                        }
                        if (value) {
                            value = self.getupdatedvalue(value);
                        }
                        paramsjson[name] = value;
                        params = JSON.stringify(paramsjson);
                        client.setAttribute(self._currentNodeId, 'Definition', params);
                        client.setAttribute(nid, 'value', value);
                    } catch (err) {
                        this._logger.error(err);
                        client.notifyUser({severity: 'error', message: err.message});
                    }

                    client.completeTransaction();
                }
            } else {
                client.startTransaction();
                try {
                    client.setAttribute(nid, 'default', value);
                } catch (err) {
                    this._logger.error(err);
                    client.notifyUser({severity: 'error', message: err.message});
                }
                client.completeTransaction();

            }
        };


        this._widget.renameAttribute = (nid, name, newName) => {

            if (!self.rosInfoId) {

                const nodeObj = client.getNode(self._currentNodeId);

                if (nodeObj) {

                    client.startTransaction();

                    try {
                        var params = nodeObj.getAttribute('Definition');
                        var paramsjson = JSON.parse(params);
                        var keys = Object.keys(paramsjson);

                        if (keys.indexOf(name) > -1) {
                            paramsjson[newName] = paramsjson[name];
                            delete paramsjson[name];
                        }
                        params = JSON.stringify(paramsjson);
                        client.setAttribute(self._currentNodeId, 'Definition', params);
                        client.setAttribute(nid, 'name', newName);
                    } catch (err) {
                        this._logger.error(err);
                        client.notifyUser({severity: 'error', message: err.message});
                    }

                    client.completeTransaction();
                }
            } else {

                client.startTransaction();

                try {
                    client.setAttribute(nid, 'name', newName);
                } catch (err) {
                    this._logger.error(err);
                    client.notifyUser({severity: 'error', message: err.message});
                }

                client.completeTransaction();

            }
        };

        this._widget.deleteAttribute = (nid, name) => {

            if (!self.rosInfoId) {

                const nodeObj = client.getNode(self._currentNodeId);

                if (nodeObj) {

                    client.startTransaction();

                    try {
                        var params = nodeObj.getAttribute('Definition');
                        var paramsjson = JSON.parse(params);
                        var keys = Object.keys(paramsjson);

                        if (keys.indexOf(name) > -1) {
                            delete paramsjson[name];
                        }
                        params = JSON.stringify(paramsjson);
                        client.setAttribute(self._currentNodeId, 'Definition', params);
                        client.deleteNode(nid);
                    } catch (err) {
                        this._logger.error(err);
                        client.notifyUser({severity: 'error', message: err.message});
                    }

                    client.completeTransaction();
                }
            } else {
                client.startTransaction();

                try {
                    client.deleteNode(nid);
                } catch (err) {
                    this._logger.error(err);
                    client.notifyUser({severity: 'error', message: err.message});
                }

                client.completeTransaction();

            }


        };


    };

    /*
        ParamsControl.prototype.onActivate = function () {
            this.logger.debug('ParamsWidget has been activated');
        };

        ParamsControl.prototype.onDeactivate = function () {
            this.logger.debug('ParamsWidget has been deactivated');
        };
    */
    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    /*    ParamsControl.prototype.destroy = function () {
            this._client.removeUI(this._uiId);
        };

    */
    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    ParamsControl.prototype.selectedObjectChanged = function (nodeId) {

        var desc = undefined,
            self = this;
        self._getObjectDescriptor(nodeId)
            .then(function (desc) {

                self._logger.debug('activeObject nodeId \'' + nodeId + '\'');
                self._logger.debug('metaname of activeobject= ' + desc.metaName);

                // Remove current territory patterns
                if (self._currentNodeId) {
                    self._client.removeUI(self._territoryId);
                }

                self._currentNodeId = nodeId;
                self._currentNodeParentId = undefined;

                if (typeof self._currentNodeId === 'string') {
                    // Put new node's info into territory rules
                    self._selfPatterns = {};
                    self._selfPatterns[nodeId] = {children: 2};  // Territory "rule"

                    self._widget.setTitle("");

                    if (typeof desc.parentId === 'string') {
                        self.$btnModelHierarchyUp.show();
                    } else {
                        self.$btnModelHierarchyUp.hide();
                    }

                    self._currentNodeParentId = desc.parentId;

                    self._territoryId = self._client.addUI(self, function (events) {
                        self._eventCallback(events);
                    });

                    // Update the territory
                    //self._client.updateTerritory(self._territoryId, self._selfPatterns);

                    //self._selfPatterns[nodeId] = {children: 100};
                    //self._client.updateTerritory(self._territoryId, self._selfPatterns);

                    self._selfPatterns[nodeId] = {children: 2};

                    if (self.nodesToVisit) {
                        var keys = Object.keys(self.nodesToVisit);
                        var i = 0;
                        for (i = 0; i != keys.length; i += 1) {
                            self._selfPatterns[keys[i]] = {children: 3};
                        }
                    }


                    self._client.updateTerritory(self._territoryId, self._selfPatterns);
                }
            });
    };

    // This next function retrieves the relevant node information for the widget
    ParamsControl.prototype._getObjectDescriptor = function (nodeId) {
        var self = this;
        var nodeObj = self._client.getNode(nodeId);
        var obj, k;


        return new Promise(function (resolve, reject) {

            if (nodeObj) {
                var objDescriptor = {
                    id: undefined,
                    metaName: undefined,
                    name: undefined,
                    current: false,
                    reference: false,
                    referenceInfo: {},
                    parameters: {},
                    isinstance: false,
                    info: {},
                    use: 0,
                    last: 0
                };

                var metaObj = self._client.getNode(nodeObj.getMetaTypeId()),
                    id = nodeObj.getId(),
                    metaName = '';

                if (metaObj) {
                    metaName = metaObj.getAttribute(nodePropertyNames.Attributes.name);
                }

                if (!self._currentNodeId) {
                    self.nodesToVisit[id] = {children: 3};

                }
                //self.getParentFolders(nodeObj);


                if (self._currentNodeId) {


                    objDescriptor.id = nodeObj.getId();
                    var parentId = nodeObj.getParentId();
                    var baseNodeID = nodeObj.getBaseId();
                    var metaID = nodeObj.getMetaTypeId();
                    objDescriptor.isinstance = false;
                    if (baseNodeID != metaID) {
                        objDescriptor.isinstance = true;
                        self._logger.info('is instance')
                    } else {
                        self._logger.info('is not  instance')
                    }
                    if ((self._currentNodeId == objDescriptor.id) && (metaName == "Params")) {
                        objDescriptor.current = true;
                        objDescriptor.metaName = metaName;
                        objDescriptor.name = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
                        objDescriptor.parameters = {};

                        var childrenIds = nodeObj.getChildrenIds();
                        var k = 0;
                        var nodeID = nodeObj.getId();

                        //var baseNode = self._client.getNode(baseNodeID);


                        for (k = 0; k < childrenIds.length; k++) {
                            var cnode = self._client.getNode(childrenIds[k]);
                            if (!cnode) {
                                continue;
                            }

                            var cmetaObj = self._client.getNode(cnode.getMetaTypeId());
                            var mname = cmetaObj.getAttribute(nodePropertyNames.Attributes.name);
                            var cname = cnode.getAttribute(nodePropertyNames.Attributes.name);
                            var cvalue = cnode.getAttribute('value');
                            var ctype = cnode.getAttribute('type');
                            if (mname == 'parameter') {
                                objDescriptor.parameters[childrenIds[k]] = [cname, cvalue, ctype];
                            }

                        }


                        objDescriptor.use = 1;
                    } else if ((self._currentNodeId == parentId) && (metaName == "ROSInfo")) {


                        objDescriptor.id = nodeObj.getId();
                        objDescriptor.current = true;

                        objDescriptor.name = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
                        objDescriptor.parameters = {};

                        var childrenIds = nodeObj.getChildrenIds();
                        var k = 0;
                        var nodeID = nodeObj.getId();

                        for (k = 0; k < childrenIds.length; k++) {
                            var cnode = self._client.getNode(childrenIds[k]);
                            if (!cnode) {
                                continue;
                            }

                            var cmetaObj = self._client.getNode(cnode.getMetaTypeId());
                            var mname = cmetaObj.getAttribute(nodePropertyNames.Attributes.name);

                            if (mname == "ROSArgument") {

                                var ptrid = cnode.getPointerId('linked_port');
                                if (ptrid)
                                {
                                    continue;
                                }

                                var cname = cnode.getAttribute(nodePropertyNames.Attributes.name);
                                var cvalue = cnode.getAttribute('default');
                                objDescriptor.parameters[childrenIds[k]] = [cname, cvalue, ''];

                            }

                        }
                        objDescriptor.use = 1;
                        objDescriptor.metaName = metaName;
                        self.rosInfoId = objDescriptor.id;


                    }
                    /*
                    else if (self.checkMetaName(metaName))
                    {
                        objDescriptor = self.updateReferenceInfo(nodeObj,metaName,objDescriptor);
                    }*/
                }

                resolve(objDescriptor);

            }
        });
    };

    ParamsControl.prototype.checkMetaName = function (metaName) {
        var self = this;
        var parentMetaTypes = ['Block', 'SystemModel', 'Environment', 'ExperimentSetup',
            'SLTrainingSetUp', 'EvaluationSetup', 'AssuranceMonitorSetup',
            'RLTrainingSetup', 'VerificationSetup', 'ValidationSetup', 'SystemIDSetup'];
        if (parentMetaTypes.indexOf(metaName) > -1) {
            return true;
        }
        return false;
    };

    ParamsControl.prototype.updateReferenceInfo = function (nodeObj, metaName, objDescriptor) {
        var self = this;
        var descriptor = objDescriptor;

        var childrenIds = nodeObj.getChildrenIds();
        var k = 0;
        var nodeID = nodeObj.getId();
        var hname = self.getHierarchicalName(nodeID);

        for (k = 0; k < childrenIds.length; k++) {
            var cnode = self._client.getNode(childrenIds[k]);
            if (!cnode) {
                continue;
            }

            var cmetaObj = self._client.getNode(cnode.getMetaTypeId());
            var mname = cmetaObj.getAttribute(nodePropertyNames.Attributes.name);

            if (mname == 'Params') {
                descriptor = self.getParamReference(cnode, descriptor, hname);

            }

        }

        return descriptor;
    };

    ParamsControl.prototype.getParamReference = function (nodeObj, objDescriptor, hname) {
        var self = this;
        var mname = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
        var descriptor = objDescriptor;
        var definition = nodeObj.getAttribute('Definition');
        var jsonval = {};
        try {
            jsonval = JSON.parse(definition);
            var nodeid = nodeObj.getId();
            var keys = Object.keys(jsonval);
            var len = keys.length;
            if (len) {

                if (!(hname in descriptor.referenceInfo)) {
                    descriptor.referenceInfo[hname] = {
                        "title": hname,
                        "folder": true,
                        "checkbox": false,
                        "unselectable": true,
                        "children": []
                    };

                }
                //descriptor.referenceInfo[hname][mname]={};
                descriptor.referenceInfo[hname]["children"].push({
                    "title": mname,
                    "folder": true,
                    "checkbox": false,
                    "unselectable": true,
                    "children": [],
                    "key": nodeid
                })
                var pos = descriptor.referenceInfo[hname]["children"].length - 1;

                var i = 0;
                for (i = 0; i != len; i += 1) {
                    var pname = keys[i];
                    var value = jsonval[pname];
                    var kstr = nodeid + "_" + i.toString();
                    descriptor.referenceInfo[hname]["children"][pos]["children"].push({
                        "title": pname,
                        "key": kstr,
                        "values": value
                    })
                    //descriptor.referenceInfo[hname][mname][pname]=[nodeid,value];
                    //descriptor.treeInfo.append()
                }
                descriptor.use = 1;
            }

        } catch (e) {
            var estr = 'Unable to parse JSON input for parameter ' + mname + ' in ' + hname;
            self._logger.error(estr);

        }
        return descriptor;

    };

    ParamsControl.prototype.getHierarchicalName = function (nodeid) {
        var self = this;
        var ret = [];
        var nid = nodeid;
        var nodeObj = self._client.getNode(nid);
        var pid = nodeObj.getParentId();
        var stoppingParentMetaTypes = ['BlockLibrary', 'BlockPackage', 'Systems', 'Assemblys', 'ExperimentSetup',
            'SLTrainingSetUp', 'EvaluationSetup', 'AssuranceMonitorSetup',
            'RLTrainingSetup', 'VerificationSetup', 'ValidationSetup', 'SystemIDSetup'];


        while (true) {

            if (nodeObj) {
                var cmetaObj = self._client.getNode(nodeObj.getMetaTypeId());
                var mname = cmetaObj.getAttribute(nodePropertyNames.Attributes.name);
                if (stoppingParentMetaTypes.indexOf(mname) > -1) {
                    break;
                }
                ret.push(nodeObj.getAttribute(nodePropertyNames.Attributes.name));
                nid = pid;
                nodeObj = self._client.getNode(nid);
                if (nodeObj) {
                    pid = nodeObj.getParentId();
                } else {
                    break;
                }
            } else {
                break;
            }

        }
        if (nodeObj) {
            ret.push(nodeObj.getAttribute(nodePropertyNames.Attributes.name));
        }

        var ret1 = ret.reverse();
        var ret2 = ret1.join('/');
        return ret2;


    };

    ParamsControl.prototype.getParentFolders = function (nodeObj) {

        var self = this;
        var ret = [];
        if (self.parentFoldersVisited)
            return ret;

        var parentNodeID, parentNode, parentMetaNode, parentMetaName;

        var stoppingParentMetaTypes = ['BlockLibrary', 'BlockPackage', 'Systems', 'ExperimentSetup',
            'SLTrainingSetUp', 'EvaluationSetup', 'AssuranceMonitorSetup',
            'RLTrainingSetup', 'VerificationSetup', 'ValidationSetup', 'SystemIDSetup'];

        var exploreMetaTypes = ['Block', 'System', 'Environment', 'ExperimentSetup',
            'SLTrainingSetUp', 'EvaluationSetup', 'AssuranceMonitorSetup',
            'RLTrainingSetup', 'VerificationSetup', 'ValidationSetup', 'SystemIDSetup'];

        parentNodeID = nodeObj.getParentId();
        parentNode = self._client.getNode(parentNodeID);


        while (parentNode) {
            parentMetaNode = self._client.getNode(parentNode.getMetaTypeId());
            if (!parentMetaNode)
                break;

            parentMetaName = parentMetaNode.getAttribute(nodePropertyNames.Attributes.name);


            if (exploreMetaTypes.indexOf(parentMetaName) > -1) {
                self.nodesToVisit[parentNodeID] = {children: 3};
            }

            if (stoppingParentMetaTypes.indexOf(parentMetaName) > -1) {
                break;
            }


            parentNodeID = parentNode.getParentId();
            parentNode = self._client.getNode(parentNodeID);
        }

        self.parentFoldersVisited = 1;


    };

    /* * * * * * * * Node Event Handling * * * * * * * */
    ParamsControl.prototype._eventCallback = function (events) {
        var i = events ? events.length : 0,
            event;

        this._logger.debug('_eventCallback \'' + i + '\' items');


        while (i--) {
            event = events[i];
            switch (event.etype) {
                case CONSTANTS.TERRITORY_EVENT_LOAD:
                    this._logger.debug('event ' + i)
                    this._onLoad(event.eid, i);
                    this.countlimit = i;
                    break;
                case CONSTANTS.TERRITORY_EVENT_UPDATE:
                    this._onUpdate(event.eid);
                    break;
                case CONSTANTS.TERRITORY_EVENT_UNLOAD:
                    this._onUnload(event.eid);
                    break;
                default:
                    break;
            }
        }

        this._logger.debug('event outside  ' + i)


        this._logger.debug('_eventCallback \'' + events.length + '\' items - DONE');
    };

    ParamsControl.prototype.getupdatedvalue = function (value) {
        var self = this;
        var val = value;
        val = val.trim();
        //null or empty
        if (!val)
        {
            return val;
        }
        //quoted string
        if (val[0]=='"' && val[val.length-1]=='"')
        {
            return val;
        }
        //number
        var numval = Number(val);
        if (!isNaN(numval))
        {
            return numval;
        }
        //boolean
        if (val == "true" || val == "True")
        {
            return true;
        }
        if (val == "false" || val == "False")
        {
            return false;
        }
        //array
        if (val[0]=='[' && val[val.length-1]==']')
        {
            try {
                var arrayval = eval(val);
                if (Array.isArray(arrayval))
                {
                    return arrayval;
                }

            } catch (err) {
            }
        }
        //dict
        if (val[0]=='{' && val[val.length-1]=='}')
        {
            try {
                var newval = "["+val+"]"
                var dictval = eval(newval);
                return dictval[0];

            } catch (err) {
            }
        }

        return val;
    };

    ParamsControl.prototype._onLoad = function (gmeId, count = -1) {
        var self = this;
        this._getObjectDescriptor(gmeId)
            .then(function (description) {
                description.last = -1;
                if (count == 1) {
                    description.last = 1;
                }

                if (description.use == 1 || description.metaName || (description.last == 1))
                    self._widget.addNode(description);

            });

    };

    ParamsControl.prototype._onUpdate = function (gmeId) {
        var self = this;
        self._getObjectDescriptor(gmeId)
            .then(function (description) {
                //self._logger.debug('metaname  _onUpdate= '+ description.metaName);
                //self._widget.updateNode(description);
            });
    };

    ParamsControl.prototype._onUnload = function (gmeId) {
        //this._widget.removeNode(gmeId);
    };

    ParamsControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
        if (this._currentNodeId === activeObjectId) {
            // The same node selected as before - do not trigger
        } else {
            this.selectedObjectChanged(activeObjectId);
        }
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    ParamsControl.prototype.destroy = function () {
        this._detachClientEventListeners();
        this._removeToolbarItems();
    };

    ParamsControl.prototype._attachClientEventListeners = function () {
        this._detachClientEventListeners();
        WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
    };

    ParamsControl.prototype._detachClientEventListeners = function () {
        WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
    };

    ParamsControl.prototype.onActivate = function () {
        this._attachClientEventListeners();
        this._displayToolbarItems();

        if (typeof this._currentNodeId === 'string') {
            WebGMEGlobal.State.registerSuppressVisualizerFromNode(true);
            WebGMEGlobal.State.registerActiveObject(this._currentNodeId);
            WebGMEGlobal.State.registerSuppressVisualizerFromNode(false);
        }
    };

    ParamsControl.prototype.onDeactivate = function () {
        this._detachClientEventListeners();
        this._hideToolbarItems();
    };

    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    ParamsControl.prototype._displayToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].show();
            }
        } else {
            this._initializeToolbar();
        }
    };

    ParamsControl.prototype._hideToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].hide();
            }
        }
    };

    ParamsControl.prototype._removeToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].destroy();
            }
        }
    };

    ParamsControl.prototype._initializeToolbar = function () {
        var self = this,
            toolBar = WebGMEGlobal.Toolbar;

        this._toolbarItems = [];

        this._toolbarItems.push(toolBar.addSeparator());

        /************** Go to hierarchical parent button ****************/
        this.$btnModelHierarchyUp = toolBar.addButton({
            title: 'Go to parent',
            icon: 'glyphicon glyphicon-circle-arrow-up',
            clickFn: function (/*data*/) {
                WebGMEGlobal.State.registerActiveObject(self._currentNodeParentId);
            }
        });
        this._toolbarItems.push(this.$btnModelHierarchyUp);
        this.$btnModelHierarchyUp.hide();

        /************** Checkbox example *******************/

        this.$cbShowConnection = toolBar.addCheckBox({
            title: 'toggle checkbox',
            icon: 'gme icon-gme_diagonal-arrow',
            checkChangedFn: function (data, checked) {
                self._logger.debug('Checkbox has been clicked!');
            }
        });
        this._toolbarItems.push(this.$cbShowConnection);

        this._toolbarInitialized = true;
    };


    return ParamsControl;
});
