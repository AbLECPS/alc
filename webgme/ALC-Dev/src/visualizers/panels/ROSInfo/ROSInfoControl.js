/*globals define, WebGMEGlobal*/
/*jshint browser: true*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Thu Jul 07 2016 11:24:16 GMT-0500 (Central Daylight Time).
 */

define(['js/Constants',
    'js/Utils/GMEConcepts',
    'js/NodePropertyNames'
], function (CONSTANTS,
             GMEConcepts,
             nodePropertyNames) {

    'use strict';

    var ROSInfoControl;

    ROSInfoControl = function (options) {

        this._logger = options.logger.fork('Control');

        this._client = options.client;

        // Initialize core collections and variables
        this._widget = options.widget;
        this._currentNodeId = null;
        this._currentNodeParentId = undefined;
        this.alcid = '';
        this.addCount = 0;
        this._initWidgetEventHandlers();
        this._logger.debug('ctor finished');
    };

    ROSInfoControl.prototype._initWidgetEventHandlers = function () {
        var self = this;

        this._widget.onNodeClick = function (id) {
            var targetNodeObj = self._client.getNode(id);
            if (targetNodeObj) {
                var address = window.location.origin + WebGMEGlobal.gmeConfig.client.mountedPath + '/?project=' + encodeURIComponent(self._client.getActiveProjectId());
                address += '&branch=' + encodeURIComponent(self._client.getActiveBranchName());
                address += '&node='+ encodeURIComponent(id);
                address += '&visualizer=Designer';
                window.open(address, '_blank');
                window.focus();
                
                /*self._logger.debug('*******************got object');
                if (targetNodeObj.getParentId() || targetNodeObj.getParentId() === CONSTANTS.PROJECT_ROOT_ID) {
                    self._logger.debug('*******************got parent id');
                    WebGMEGlobal.State.registerActiveObject(targetNodeObj.getParentId());
                    WebGMEGlobal.State.registerActiveSelection([id]);
                    WebGMEGlobal.State.registerActiveVisualizer('ModelEditor');
                }*/

            }

        };

       	
        	
        this._widget.onEditModeInfo = function (id, oldids, newids) {
            self._logger.debug(' on edit onEditNode1');
            var i=0;
            var ol = oldids.length;
            var nl = newids.length;
            var dl = [];
            var al = [];

            var i =0;
            for (i=0; i!= oldids.length; i+=1)
            {
                var id = oldids[i];
                if (newids.indexOf(id)==-1)
                {
                    dl.push(id);
                }

            }

            for (i=0; i!= newids.length; i+=1)
            {
                var id = newids[i];
                if (oldids.indexOf(id)==-1)
                {
                    al.push(id);
                }

            }

            if ((dl.length == 0) && (al.length==0))
				return;
            
            self._client.startTransaction('updating implementation selection');
            for (i=0; i!= dl.length; i+=1)
            {
                var id = dl[i];
                self._client.setAttributes(id,'IsActive',false);
            }

            for (i=0; i!= al.length; i+=1)
            {
                var id = al[i];
                self._client.setAttributes(id,'IsActive',true);
            }
            
            self._client.completeTransaction('updated implementation selection', function (err, result) {
                self._logger.debug(result.hash);
                self._logger.debug(result.status);
            });
        };

        this._widget.onEditParameterInfo = function (id, oldvalue, newvalue) {
            self._logger.debug(' on edit onEditParameterInfo');
            
            if (oldvalue == newvalue)
				return;
            
            self._client.startTransaction('updating parameter table');
            self._client.setAttributes(id,'Definition',newvalue);
            self._client.completeTransaction('updated parameter table', function (err, result) {
                self._logger.debug(result.hash);
                self._logger.debug(result.status);
            });
        };

        this._widget.onEditMessageInfo = function (id,value,rawtext) {
            self._logger.debug(' on edit Message');
            self._client.startTransaction('updating message');
            self._client.setPointer(id, 'messagetype', value);
            //self._client.setAttribute(id, 'MessageType', rawtext);
            self._client.completeTransaction('updated message', function (err, result) {
                self._logger.debug(result.hash);
                self._logger.debug(result.status);
            });
        };

        this._widget.onEditTopicInfo = function (portid, value) {
            self._logger.debug(' on edit Topic');
            
            self._client.startTransaction('updating topic');
            //self._client.setPointer(id, 'ModelDataLink', value);
            self._client.setAttributes(portid,'Topic',value)
            self._client.completeTransaction('updated topic', function (err, result) {
                self._logger.debug(result.hash);
                self._logger.debug(result.status);
            });
        };

        this._widget.onEditTypeInfo = function (portid, value, idx) {
            self._logger.debug(' on edit Port Type');
            var typelist = ['Output','Input','InputOutput','InputOutput', 'InputOutput', 'InputOutput','Input']
            var direction = typelist[idx];
            self._client.startTransaction('updating port type');
            //self._client.setPointer(id, 'ModelDataLink', value);
            self._client.setAttributes(portid,'PortType',value)
            self._client.setAttributes(portid,'Direction',direction)
            self._client.completeTransaction('updated port type', function (err, result) {
                self._logger.debug(result.hash);
                self._logger.debug(result.status);
            });
        };

    };

    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    ROSInfoControl.prototype.selectedObjectChanged = function (nodeId) {
    
        var desc =  undefined,
                self = this;
        self._getObjectDescriptor(nodeId)
            .then(function(desc) {

                self._logger.debug('activeObject nodeId \'' + nodeId + '\'');
                self._logger.debug('metaname of activeobject= '+ desc.metaName);
        
                // Remove current territory patterns
                if (self._currentNodeId) {
                    self._client.removeUI(self._territoryId);
                }

                self._currentNodeId = nodeId;
                self._currentNodeParentId = undefined;

                if (typeof self._currentNodeId === 'string') {
                    // Put new node's info into territory rules
                    self._selfPatterns = {};
                    self._selfPatterns[nodeId] = {children: 0};  // Territory "rule"

                    self._widget.setTitle("ROSInfo");

                    if (typeof desc.parentId === 'string') {
                        self.$btnModelHierarchyUp.show();
                    } else {
                        self.$btnModelHierarchyUp.hide();
                    }

                    self._currentNodeParentId = desc.parentId;

                    self._territoryId = self._client.addUI(self, function (events) {
                        self._eventCallback(events);
                    });

                    // Update the territory
                    self._client.updateTerritory(self._territoryId, self._selfPatterns);

                    self._selfPatterns[nodeId] = {children: 100};
                    if (self.alcid)
                    {
                        self._selfPatterns[self.alcid] = { children: 5 };
                    }
                    
                    self._client.updateTerritory(self._territoryId, self._selfPatterns);
                }
            });
    };

    // This next function retrieves the relevant node information for the widget
    ROSInfoControl.prototype._getObjectDescriptor = function (nodeId) {
        var self=this;
        var nodeObj = self._client.getNode(nodeId);
        var obj, k;
            
	
        return new Promise(function(resolve,reject) {
	
            if (nodeObj) {
                var objDescriptor = {
                    id: undefined,
                    parentId: undefined,
                    metaName: undefined,
                    name: undefined,
					phname: undefined,
                    ports : {},
                    messageInfo: {},
                    isROSNode : 0,
                    nodetype: '',
					use: 0
                };
                
                var metaObj = self._client.getNode(nodeObj.getMetaTypeId());
				objDescriptor.id = nodeObj.getId();
				objDescriptor.name = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
				objDescriptor.parentId = nodeObj.getParentId();
				
                if (metaObj) {
                    var metaname  = metaObj.getAttribute(nodePropertyNames.Attributes.name);
                    objDescriptor.metaName =  metaname;

                    if (!self._currentNodeId && !(self.alcid))
                    {
                        self.getParentFolders(nodeObj);
                        resolve(objDescriptor);
                       
                    }
                    else{
                   
                        if ((self._currentNodeId) &&(objDescriptor.metaName == 'Block'))
                        {
                            
                            var childrenIds = nodeObj.getChildrenIds();
                            var incontext = 0;
                            var phname  = self.getHierName(objDescriptor.id);
                            if (phname == '')
                            {
                                resolve(objDescriptor);
                            }
                            var noderole = nodeObj.getAttribute('Role');
                            var isrosnode = ((noderole=='Node') || (noderole=='Simulation')|| (noderole=='Driver')|| (noderole=='Simulation Component')|| (noderole=='Node Bridge'));
                            if (!isrosnode)
                            {
                                resolve(objDescriptor);
                            }

                            var isImplementation = nodeObj.getAttribute('IsImplementation');
                            var isActive = nodeObj.getAttribute('IsActive');

                            if ((nodeId!= self._currentNodeId) && isImplementation && !isActive)
                            {
                                resolve(objDescriptor);
                            }
                            else if (phname != '' && isrosnode)
                            {
                            
                                objDescriptor.phname = phname;
                                objDescriptor.ports = {};
                                objDescriptor.isROSNode = 1;
                                objDescriptor.use = 1;
                                objDescriptor.nodetype = noderole;
                                
                                for (k=0; k<childrenIds.length; k++)
                                {
                                    var cnode = self._client.getNode(childrenIds[k]);
                                    if (!cnode)
                                    {
                                        resolve(objDescriptor);
                                    }
                                    var cmetaObj = self._client.getNode(cnode.getMetaTypeId());
                                    var mname = cmetaObj.getAttribute(nodePropertyNames.Attributes.name);
                                    var cname = cnode.getAttribute(nodePropertyNames.Attributes.name);
                                    var cid  = childrenIds[k];
                                    if (mname == 'SignalPort')
                                    {
                                        var direction =   cnode.getAttribute('Direction');
                                        var ptype =   cnode.getAttribute('PortType');
                                        if (ptype == 'Other' || ptype == 'Signal')
                                        {
                                            continue;
                                        }
                                        objDescriptor.ports[cid]={'name':cname,'mid':-1, 'topic':'', 'type':'','direction':'','issues':'','inftopic':''}
                                        var messagetypeid =   cnode.getPointerId('messagetype');
                                        if (messagetypeid)
                                        {
                                            objDescriptor.ports[cid]['mid'] = messagetypeid;
                                        }

                                        var topic =   cnode.getAttribute('Topic');
                                        if (topic)
                                        {
                                            objDescriptor.ports[cid]['topic'] = topic;
                                        }

                                        
                                        if (ptype)
                                        {
                                            objDescriptor.ports[cid]['type'] = ptype;
                                        }

                                        var direction =   cnode.getAttribute('Direction');
                                        if (direction)
                                        {
                                            objDescriptor.ports[cid]['direction'] = direction;
                                        }

                                        var issues = cnode.getAttribute('issues')
                                        objDescriptor.ports[cid]['issues'] = issues;

                                        var inftopic = cnode.getAttribute('inferredTopic')
                                        objDescriptor.ports[cid]['inftopic'] = inftopic;
                                        self._logger.debug('inferred topic: '+inftopic);
                                        

                                    }
                                        
                                }
                            }
                            
                        }

                        if ((self._currentNodeId) && ((objDescriptor.metaName=="MessageType")|| (objDescriptor.metaName=="ActionType")|| (objDescriptor.metaName=="ServiceType"))) {                        
                            var parentId = objDescriptor.parentId;
                            var parentObj = '';
                            var pMetaName = '';
                            var packageName = '';
                            if (parentId) {
                                parentObj = self._client.getNode(parentId);
                                if (parentObj) {

                                    var pmetaObj = self._client.getNode(parentObj.getMetaTypeId());
                                    if (pmetaObj)
                                        pMetaName = pmetaObj.getAttribute(nodePropertyNames.Attributes.name);
                                        if (pMetaName == 'MessagePackage')
                                        {
                                            packageName = parentObj.getAttribute(nodePropertyNames.Attributes.name);
                                        }

                                }
                                objDescriptor.messageInfo = {'id':'','type':'','package':'','messagename':''}
                                objDescriptor.messageInfo['id'] = nodeObj.getId();
                                objDescriptor.messageInfo['package'] = packageName;
                                objDescriptor.messageInfo['messagename'] = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
                                objDescriptor.messageInfo['type'] =objDescriptor.metaName
                                objDescriptor.use = 1;
                            }
                        }
                    }

                    resolve(objDescriptor);
                }
                else {
                    resolve(objDescriptor);
                }
            }
            else {
                resolve(objDescriptor);
            }
        });
    };

    
    
    ROSInfoControl.prototype.getHierName = function (nodeid) {
        var self = this;
		var pid = nodeid;
		var nodeObj;
        var ret='';
        if (nodeid == self._currentNodeId && self._currentNodeParentId)
        {
            nodeObj = self._client.getNode(nodeid);
            ret = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
            return ret;
        }
		while (pid != self._currentNodeId)
		{
			nodeObj = self._client.getNode(pid);
			if (nodeObj)
			{	
				if (ret)
				{
				  var ret1 = ret;
				  ret = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
				  ret += '/';
                  ret += ret1; 
					
				}
                else
                {
                    ret = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
                }
				pid = nodeObj.getParentId();
            }
            else
            {
                return '';
            }
        
			
        }
        if (pid == self._currentNodeId)
            return ret;
        
        return '';
        
    };

    ROSInfoControl.prototype.getParentFolders = function (nodeObj) {

        var self = this;
        var ret = [];
        if (self.alcid )
            return ret;

        //self._logger.debug('******* in getParentFolders');

        var parentNodeID, parentNode, parentMetaNode, parentMetaName;
        var alcMetaType = 'ALC';
        parentNodeID = nodeObj.getParentId();
        parentNode = self._client.getNode(parentNodeID);

        var metaobj = self._client.getNode(nodeObj.getMetaTypeId());
        var metaName = metaobj.getAttribute(nodePropertyNames.Attributes.name);
        

        while (parentNode) {
            parentMetaNode = self._client.getNode(parentNode.getMetaTypeId());
            if (!parentMetaNode)
                break;

            parentMetaName = parentMetaNode.getAttribute(nodePropertyNames.Attributes.name);

            if (parentMetaName.indexOf(alcMetaType) != -1) {
                self.alcid = parentNodeID;
                break;
            }

            
            parentNodeID = parentNode.getParentId();
            parentNode = self._client.getNode(parentNodeID);

        }

    };



    /* * * * * * * * Node Event Handling * * * * * * * */
    ROSInfoControl.prototype._eventCallback = function (events) {
        var i = events ? events.length : 0,
            event;

        //this._logger.debug('_eventCallback \'' + i + '\' items');

        while (i--) {
            event = events[i];
            switch (event.etype) {
                case CONSTANTS.TERRITORY_EVENT_LOAD:
                    this._onLoad(event.eid,i);
                    break;
                case CONSTANTS.TERRITORY_EVENT_UPDATE:
                    this._onUpdate(event.eid);
                    break;
                case CONSTANTS.TERRITORY_EVENT_UNLOAD:
                    this._onUnload(event.eid);
                    break;
                default:
                    break;
            }
        }

        //this._logger.debug('_eventCallback \'' + events.length + '\' items - DONE');
    };

    ROSInfoControl.prototype._onLoad = function(gmeId,count=-1){
		var self= this;
		 this._getObjectDescriptor(gmeId)
          .then(function(description) {
              description.last=-1;
              if (count==1){
                  if (self.addCount !=0)
                  {
                    description.last=1;
                  }

                  
              }
              //self._logger.debug('metaname  _onLoad= '+ description.faultlabel);
              //if ((description.last==1)||((description.use ==1 ) && ((description.metaName == 'Block')||(description.metaName == 'Result')|| (description.metaName == "Params"))))
              if ((description.last==1)|| ((description.use ==1 ) && ((description.metaName == 'Block')||(description.metaName == 'MessageType')||(description.metaName == 'ActionType')||(description.metaName == 'ServiceType'))))
			  {
                //self._logger.debug('metaname ' + description.metaName + ' hname  \'' + description.phname );
                 self._widget.addNode(description);
                 self.addCount=1;
			  }
          });
		  
        
    };

        ROSInfoControl.prototype._onUpdate = function (gmeId) {
            var self=this;
            self._getObjectDescriptor(gmeId)
            .then(function(description) {
                //self._logger.debug('metaname  _onUpdate= '+ description.metaName);
                self._widget.updateNode(description);
            });
        };

        ROSInfoControl.prototype._onUnload = function (gmeId) {
            this._widget.removeNode(gmeId);
        };

        ROSInfoControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
            if (this._currentNodeId === activeObjectId) {
                // The same node selected as before - do not trigger
            } else {
                this.selectedObjectChanged(activeObjectId);
            }
        };

        /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
        ROSInfoControl.prototype.destroy = function () {
            this._detachClientEventListeners();
            this._removeToolbarItems();
        };

        ROSInfoControl.prototype._attachClientEventListeners = function () {
            this._detachClientEventListeners();
            WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
        };

        ROSInfoControl.prototype._detachClientEventListeners = function () {
            WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
        };

        ROSInfoControl.prototype.onActivate = function () {
            this._attachClientEventListeners();
            this._displayToolbarItems();

            if (typeof this._currentNodeId === 'string') {
                WebGMEGlobal.State.registerSuppressVisualizerFromNode(true);
                WebGMEGlobal.State.registerActiveObject(this._currentNodeId);
                WebGMEGlobal.State.registerSuppressVisualizerFromNode(false);
            }
        };

        ROSInfoControl.prototype.onDeactivate = function () {
            this._detachClientEventListeners();
            this._hideToolbarItems();
        };

        /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
        ROSInfoControl.prototype._displayToolbarItems = function () {

            if (this._toolbarInitialized === true) {
                for (var i = this._toolbarItems.length; i--;) {
                    this._toolbarItems[i].show();
                }
            } else {
                this._initializeToolbar();
            }
        };

        ROSInfoControl.prototype._hideToolbarItems = function () {

            if (this._toolbarInitialized === true) {
                for (var i = this._toolbarItems.length; i--;) {
                    this._toolbarItems[i].hide();
                }
            }
        };

        ROSInfoControl.prototype._removeToolbarItems = function () {

            if (this._toolbarInitialized === true) {
                for (var i = this._toolbarItems.length; i--;) {
                    this._toolbarItems[i].destroy();
                }
            }
        };

        ROSInfoControl.prototype._initializeToolbar = function () {
            var self = this,
                toolBar = WebGMEGlobal.Toolbar;

            this._toolbarItems = [];

            this._toolbarItems.push(toolBar.addSeparator());

            /************** Go to hierarchical parent button ****************/
            this.$btnModelHierarchyUp = toolBar.addButton({
                title: 'Go to parent',
                icon: 'glyphicon glyphicon-circle-arrow-up',
                clickFn: function (/*data*/) {
                    WebGMEGlobal.State.registerActiveObject(self._currentNodeParentId);
                }
            });
            this._toolbarItems.push(this.$btnModelHierarchyUp);
            this.$btnModelHierarchyUp.hide();

            /************** Checkbox example *******************/

            this.$cbShowConnection = toolBar.addCheckBox({
                title: 'toggle checkbox',
                icon: 'gme icon-gme_diagonal-arrow',
                checkChangedFn: function (data, checked) {
                    self._logger.debug('Checkbox has been clicked!');
                }
            });
            this._toolbarItems.push(this.$cbShowConnection);

            this._toolbarInitialized = true;
        };

        return ROSInfoControl;
    });
