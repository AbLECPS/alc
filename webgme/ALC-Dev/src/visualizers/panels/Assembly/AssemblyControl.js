/*globals define, WebGMEGlobal*/
/*jshint browser: true*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Thu Jul 07 2016 11:24:16 GMT-0500 (Central Daylight Time).
 */

define(['js/Constants',
    'js/Utils/GMEConcepts',
    'js/NodePropertyNames'
], function (CONSTANTS,
             GMEConcepts,
             nodePropertyNames) {

    'use strict';

    var AssemblyControl;

    AssemblyControl = function (options) {

        this._logger = options.logger.fork('Control');

        this._client = options.client;

        // Initialize core collections and variables
        this._widget = options.widget;
        this._currentNodeId = null;
        this._currentNodeParentId = undefined;
        this.alcrootid = '';
        this.alcid = '';
        this._initWidgetEventHandlers();
        this._logger.debug('ctor finished');
    };

    AssemblyControl.prototype._initWidgetEventHandlers = function () {
        var self = this;
        this._widget.onNodeClick = function (id) {
            var targetNodeObj = self._client.getNode(id);
            if (targetNodeObj) {
                self._logger.debug('*******************got object');
                if (targetNodeObj.getParentId() || targetNodeObj.getParentId() === CONSTANTS.PROJECT_ROOT_ID) {
                    self._logger.debug('*******************got parent id');
                    WebGMEGlobal.State.registerActiveObject(targetNodeObj.getParentId());
                    WebGMEGlobal.State.registerActiveSelection([id]);
                    WebGMEGlobal.State.registerActiveVisualizer('ModelEditor');
                } 
	     
            }
	   
        };
	
        	
        this._widget.onEditModeInfo = function (id, oldids, newids) {
            self._logger.debug(' on edit onEditNode1');
            var i=0;
            var ol = oldids.length;
            var nl = newids.length;
            var dl = [];
            var al = [];

            var i =0;
            for (i=0; i!= oldids.length; i+=1)
            {
                var id = oldids[i];
                if (newids.indexOf(id)==-1)
                {
                    dl.push(id);
                }

            }

            for (i=0; i!= newids.length; i+=1)
            {
                var id = newids[i];
                if (oldids.indexOf(id)==-1)
                {
                    al.push(id);
                }

            }

            if ((dl.length == 0) && (al.length==0))
				return;
            
            self._client.startTransaction('updating implementation selection');
            for (i=0; i!= dl.length; i+=1)
            {
                var id = dl[i];
                self._client.setAttributes(id,'IsActive',false);
            }

            for (i=0; i!= al.length; i+=1)
            {
                var id = al[i];
                self._client.setAttributes(id,'IsActive',true);
            }
            
            self._client.completeTransaction('updated implementation selection', function (err, result) {
                self._logger.debug(result.hash);
                self._logger.debug(result.status);
            });
        };

        this._widget.onEditParameterInfo = function (id, oldvalue, newvalue) {
            self._logger.debug(' on edit onEditParameterInfo');
            
            if (oldvalue == newvalue)
				return;
            
            self._client.startTransaction('updating parameter table');
            self._client.setAttributes(id,'Definition',newvalue);
            self._client.completeTransaction('updated parameter table', function (err, result) {
                self._logger.debug(result.hash);
                self._logger.debug(result.status);
            });
        };

        this._widget.onEditLECInfo = function (id,value) {
            self._logger.debug(' on edit onEditNode1');
            self._client.startTransaction('updating lec selection');
            self._client.setPointer(id, 'ModelDataLink', value);
            self._client.completeTransaction('updated selection', function (err, result) {
                self._logger.debug(result.hash);
                self._logger.debug(result.status);
            });
        };
    };

    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    AssemblyControl.prototype.selectedObjectChanged = function (nodeId) {
    
        var desc =  undefined,
                self = this;
        self._getObjectDescriptor(nodeId)
            .then(function(desc) {

                self._logger.debug('activeObject nodeId \'' + nodeId + '\'');
                self._logger.debug('metaname of activeobject= '+ desc.metaName);
        
                // Remove current territory patterns
                if (self._currentNodeId) {
                    self._client.removeUI(self._territoryId);
                }

                self._currentNodeId = nodeId;
                self._currentNodeParentId = undefined;

                if (typeof self._currentNodeId === 'string') {
                    // Put new node's info into territory rules
                    self._selfPatterns = {};
                    self._selfPatterns[nodeId] = {children: 0};  // Territory "rule"

                    self._widget.setTitle("Implementation Selection");

                    if (typeof desc.parentId === 'string') {
                        self.$btnModelHierarchyUp.show();
                    } else {
                        self.$btnModelHierarchyUp.hide();
                    }

                    self._currentNodeParentId = desc.parentId;

                    self._territoryId = self._client.addUI(self, function (events) {
                        self._eventCallback(events);
                    });

                    // Update the territory
                    self._client.updateTerritory(self._territoryId, self._selfPatterns);

                    self._selfPatterns[nodeId] = {children: 100};
                    if (self.alcid)
                    {
                        self._selfPatterns[self.alcid] = { children: 5 };
                    }
                    if (self.alcrootid)
                    {
                        self._selfPatterns[self.alcrootid] = { children: 3 };
                    }
                    self._client.updateTerritory(self._territoryId, self._selfPatterns);
                }
            });
    };

    // This next function retrieves the relevant node information for the widget
    AssemblyControl.prototype._getObjectDescriptor = function (nodeId) {
        var self=this;
        var nodeObj = self._client.getNode(nodeId);
        var obj, k;
            
	
        return new Promise(function(resolve,reject) {
	
            if (nodeObj) {
                var objDescriptor = {
                    id: undefined,
					parentId: undefined,
					phname: undefined,
                    name: undefined,
                    modevars: undefined,
					initialmode: [],
                    systemmodes: undefined,
                    metaName: undefined,
                    params: {},
                    paramValues : {},
                    lecmodels:{},
                    lecmodelValues:{},
                    results: undefined,
                    exptName: undefined,
                    implID: undefined,
					use: 0
                };

                

                
                var metaObj = self._client.getNode(nodeObj.getMetaTypeId());
				objDescriptor.id = nodeObj.getId();
				objDescriptor.name = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
				objDescriptor.parentId = nodeObj.getParentId();
				
                if (metaObj) {
                    var metaname  = metaObj.getAttribute(nodePropertyNames.Attributes.name);
                    objDescriptor.metaName =  metaname;

                    if (!self._currentNodeId && !(self.alcrootid || self.alcid))
                    {
                        self.getParentFolders(nodeObj);
                        resolve(objDescriptor);
                    }
                    
                   
					if ((self._currentNodeId) &&(objDescriptor.metaName == 'Block'))
					{
                        
						var childrenIds = nodeObj.getChildrenIds();
                        var incontext = 0;
                        var phname  = self.getHierName(objDescriptor.parentId );
                        if (phname == '')
                        {
                            resolve(objDescriptor);
                        }
                        objDescriptor.phname = phname;
                        objDescriptor.modevars = {};
                        objDescriptor.initialmode = [];
                        objDescriptor.params = {};
                        objDescriptor.paramValues ={};
                        objDescriptor.lecmodels = {};
                        objDescriptor.lecmodelValues ={};
                        
                        var isparentimpl = nodeObj.getAttribute('IsImplementation');
                        if (!isparentimpl)
                        {
                            objDescriptor.implID = self.checkForParentImpl(objDescriptor.id);
                            if (objDescriptor.implID)
                            {
                                isparentimpl = true;
                                objDescriptor.phname, objDescriptor.name = self.getHierName(objDescriptor.implID,true)
                            }
                        }
                        else{
                            objDescriptor.implID = objDescriptor.id;
                        }

                        
                        
                        
						for (k=0; k<childrenIds.length; k++)
						{
                            var cnode = self._client.getNode(childrenIds[k]);
                            if (!cnode)
                            {
                                resolve(objDescriptor);
                            }
							var cmetaObj = self._client.getNode(cnode.getMetaTypeId());
                            var mname = cmetaObj.getAttribute(nodePropertyNames.Attributes.name);
                            var cname = cnode.getAttribute(nodePropertyNames.Attributes.name);
							if (mname == 'Block')
							{
                                
                                var isimpl = cnode.getAttribute('IsImplementation');
                                var isactive = cnode.getAttribute('IsActive');
                                if (!isimpl)
                                    continue;
                                objDescriptor.use=1;
                                objDescriptor.modevars[cname] = childrenIds[k];
                                if (isactive)
                                    objDescriptor.initialmode.push(cname);
                            }

                            if (!isparentimpl)
                            {
                                continue;
                            }

                            if (mname == 'Params')
                            {
                                objDescriptor.use=1;
                                objDescriptor.params[childrenIds[k]]=cname;
                                objDescriptor.paramValues[childrenIds[k]] = cnode.getAttribute('Definition');
                            }

                            if (mname == 'LEC_Model')
                            {
                                objDescriptor.use=1;
                                objDescriptor.lecmodels[childrenIds[k]]=cname;
                                objDescriptor.lecmodelValues[childrenIds[k]] = '';
                                var ptrid = cnode.getPointerId('ModelDataLink');
                                if (ptrid)
                                {
                                    objDescriptor.lecmodelValues[childrenIds[k]] = ptrid;
                                }
                            }
								
						}
                    }

                    if ((self._currentNodeId) && (objDescriptor.metaName=="Result")) {                        
                        var parentId = objDescriptor.parentId;
                        var parentObj = '';
                        var pMetaName = '';
                        if (parentId) {
                            parentObj = self._client.getNode(parentId);
                            if (parentObj) {

                                var pmetaObj = self._client.getNode(parentObj.getMetaTypeId());
                                if (pmetaObj)
                                    pMetaName = pmetaObj.getAttribute(nodePropertyNames.Attributes.name);

                            }
                        }

                        if (pMetaName && self.checkMetaType(pMetaName)) {
                            objDescriptor.id = nodeObj.getId();
                            objDescriptor.childrenIds = nodeObj.getChildrenIds();
                            objDescriptor.exptName = parentObj.getAttribute(nodePropertyNames.Attributes.name);
                            objDescriptor.results = {};
                            var k = 0;
                            var lresults = {};
                            for (k = 0; k < objDescriptor.childrenIds.length; k++) {
                                var cnode = self._client.getNode(objDescriptor.childrenIds[k]);
                                if (cnode)
                                {
                                    var clobj = self._client.getNode(cnode.getMetaTypeId());
                                    if (clobj)
                                    {
                                        var clname = clobj.getAttribute(nodePropertyNames.Attributes.name);
                                        if (clname.indexOf('Data') != -1) {
											var datainfo = cnode.getAttribute('datainfo');
											if ((datainfo != '')&& (datainfo != '{}'))
											{
										        var lname = cnode.getAttribute(nodePropertyNames.Attributes.name);
												lresults[lname] = objDescriptor.childrenIds[k];
											}
                                        }
                                    }
                                }
                            }
                            var sortednames = Object.keys(lresults);
                            sortednames = sortednames.sort();
                            if (sortednames.length)
                            {
                                objDescriptor.use=1;
                            }
                            for (k = 0; k < sortednames.length; k++) {
                                objDescriptor.results[sortednames[k]] = lresults[sortednames[k]];
                            }


                        }
                    }

                    if ((self._currentNodeId) &&(objDescriptor.metaName == 'Params'))
                    {
                        var phname  = self.getHierName(objDescriptor.parentId );
                        if (phname == '')
                        {
                            resolve(objDescriptor);
                        }
                        objDescriptor.id = nodeObj.getId();
                        objDescriptor.paramValues = nodeObj.getAttribute('Definition');
                        objDescriptor.use = 1;
                    }

                    

                    resolve(objDescriptor);
                }
                else {
                    resolve(objDescriptor);
                }
            }
            else {
                resolve(objDescriptor);
            }
        });
    };

    AssemblyControl.prototype.checkMetaType = function (name) {
        var self = this;
        var i = 0;
        if (name.indexOf("SLTrainingSetUp")!=-1) {
                return 1;
        }

        if (name.indexOf("RLTrainingSetup")!=-1) {
            return 1;
        }
        
         if (name.indexOf("AssuranceMonitorSetup")!=-1) {
            return 1;
        }
        
        return 0;
    };
    
    AssemblyControl.prototype.getHierName = function (nodeid, getparent=false) {
        var self = this;
		var pid = nodeid;
		var nodeObj;
        var ret='';
        var name = '';
        if (getparent)
        {
            nodeObj = self._client.getNode(nodeid);
            if (nodeObj)
            {
                name = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
                pid = nodeObj.getParentId();
            }
        }
		while (pid != self._currentNodeId)
		{
            nodeObj = self._client.getNode(pid);
            
			if (nodeObj)
			{	
				if (ret)
				{
				  var ret1 = ret;
				  ret = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
				  ret += '/';
                  ret += ret1; 
					
				}
                else
                {
                    ret = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
                }
				pid = nodeObj.getParentId();
            }
            else
            {
                if (getparent)
                {
                    return '','';
                }
                return '';
            }
        
			
        }
        if (pid == self._currentNodeId)
        {
            if (getparent)
            {
                return ret, name;
            }
            
            return ret;
        }
        
        if (getparent)
        {
            return '','';
        }
        return '';
        
    };

    AssemblyControl.prototype.checkForParentImpl = function (nodeid) {
        var self = this;
		var pid = nodeid;
		var nodeObj;
        var ret=undefined;
        
		while (pid != self._currentNodeId)
		{
            nodeObj = self._client.getNode(pid);
            
			if (nodeObj)
			{	
                if (nodeObj.getAttribute('IsImplementation'))
                {
                    ret = pid;
                    break;
                }
				pid = nodeObj.getParentId();
            }
            else
            {
                break;
            }
			
        }
        return ret;
        
    };

    AssemblyControl.prototype.getParentFolders = function (nodeObj) {

        var self = this;
        var ret = [];
        if (self.alcid || self.alcrootid)
            return ret;

        self._logger.debug('******* in getParentFolders');

        var parentNodeID, parentNode, parentMetaNode, parentMetaName;
        var alcRootMetaType = 'ALC_ROOT';
        var alcMetaType = 'ALC';
        parentNodeID = nodeObj.getParentId();
        parentNode = self._client.getNode(parentNodeID);

        var metaobj = self._client.getNode(nodeObj.getMetaTypeId());
        var metaName = metaobj.getAttribute(nodePropertyNames.Attributes.name);
        

        while (parentNode) {
            parentMetaNode = self._client.getNode(parentNode.getMetaTypeId());
            if (!parentMetaNode)
                break;

            parentMetaName = parentMetaNode.getAttribute(nodePropertyNames.Attributes.name);

            if (parentMetaName.indexOf(alcMetaType) != -1) {
                self.alcid = parentNodeID;
                break;
            }

            if (parentMetaName.indexOf(alcRootMetaType) != -1) {
                self.alcrootid = parentNodeID;
                break;
            }
            parentNodeID = parentNode.getParentId();
            parentNode = self._client.getNode(parentNodeID);

        }

    };



    /* * * * * * * * Node Event Handling * * * * * * * */
    AssemblyControl.prototype._eventCallback = function (events) {
        var i = events ? events.length : 0,
            event;

        this._logger.debug('_eventCallback \'' + i + '\' items');

        while (i--) {
            event = events[i];
            switch (event.etype) {
                case CONSTANTS.TERRITORY_EVENT_LOAD:
                    this._onLoad(event.eid,i);
                    break;
                case CONSTANTS.TERRITORY_EVENT_UPDATE:
                    this._onUpdate(event.eid);
                    break;
                case CONSTANTS.TERRITORY_EVENT_UNLOAD:
                    this._onUnload(event.eid);
                    break;
                default:
                    break;
            }
        }

        this._logger.debug('_eventCallback \'' + events.length + '\' items - DONE');
    };

    AssemblyControl.prototype._onLoad = function(gmeId,count=-1){
		var self= this;
		 this._getObjectDescriptor(gmeId)
          .then(function(description) {
              description.last=-1;
              if (count==1){
                  description.last=1;
              }
              //self._logger.debug('metaname  _onLoad= '+ description.faultlabel);
              //if ((description.last==1)||((description.use ==1 ) && ((description.metaName == 'Block')||(description.metaName == 'Result')|| (description.metaName == "Params"))))
              if ((description.last==1)||((description.use ==1 ) && ((description.metaName == 'Block')||(description.metaName == 'Result'))))
			  {
				 
				 self._widget.addNode(description);
			  }
          });
		  
        
    };

        AssemblyControl.prototype._onUpdate = function (gmeId) {
            var self=this;
            self._getObjectDescriptor(gmeId)
            .then(function(description) {
                //self._logger.debug('metaname  _onUpdate= '+ description.metaName);
                self._widget.updateNode(description);
            });
        };

        AssemblyControl.prototype._onUnload = function (gmeId) {
            this._widget.removeNode(gmeId);
        };

        AssemblyControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
            if (this._currentNodeId === activeObjectId) {
                // The same node selected as before - do not trigger
            } else {
                this.selectedObjectChanged(activeObjectId);
            }
        };

        /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
        AssemblyControl.prototype.destroy = function () {
            this._detachClientEventListeners();
            this._removeToolbarItems();
        };

        AssemblyControl.prototype._attachClientEventListeners = function () {
            this._detachClientEventListeners();
            WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
        };

        AssemblyControl.prototype._detachClientEventListeners = function () {
            WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
        };

        AssemblyControl.prototype.onActivate = function () {
            this._attachClientEventListeners();
            this._displayToolbarItems();

            if (typeof this._currentNodeId === 'string') {
                WebGMEGlobal.State.registerSuppressVisualizerFromNode(true);
                WebGMEGlobal.State.registerActiveObject(this._currentNodeId);
                WebGMEGlobal.State.registerSuppressVisualizerFromNode(false);
            }
        };

        AssemblyControl.prototype.onDeactivate = function () {
            this._detachClientEventListeners();
            this._hideToolbarItems();
        };

        /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
        AssemblyControl.prototype._displayToolbarItems = function () {

            if (this._toolbarInitialized === true) {
                for (var i = this._toolbarItems.length; i--;) {
                    this._toolbarItems[i].show();
                }
            } else {
                this._initializeToolbar();
            }
        };

        AssemblyControl.prototype._hideToolbarItems = function () {

            if (this._toolbarInitialized === true) {
                for (var i = this._toolbarItems.length; i--;) {
                    this._toolbarItems[i].hide();
                }
            }
        };

        AssemblyControl.prototype._removeToolbarItems = function () {

            if (this._toolbarInitialized === true) {
                for (var i = this._toolbarItems.length; i--;) {
                    this._toolbarItems[i].destroy();
                }
            }
        };

        AssemblyControl.prototype._initializeToolbar = function () {
            var self = this,
                toolBar = WebGMEGlobal.Toolbar;

            this._toolbarItems = [];

            this._toolbarItems.push(toolBar.addSeparator());

            /************** Go to hierarchical parent button ****************/
            this.$btnModelHierarchyUp = toolBar.addButton({
                title: 'Go to parent',
                icon: 'glyphicon glyphicon-circle-arrow-up',
                clickFn: function (/*data*/) {
                    WebGMEGlobal.State.registerActiveObject(self._currentNodeParentId);
                }
            });
            this._toolbarItems.push(this.$btnModelHierarchyUp);
            this.$btnModelHierarchyUp.hide();

            /************** Checkbox example *******************/

            this.$cbShowConnection = toolBar.addCheckBox({
                title: 'toggle checkbox',
                icon: 'gme icon-gme_diagonal-arrow',
                checkChangedFn: function (data, checked) {
                    self._logger.debug('Checkbox has been clicked!');
                }
            });
            this._toolbarItems.push(this.$cbShowConnection);

            this._toolbarInitialized = true;
        };

        return AssemblyControl;
    });
