/*globals define, WebGMEGlobal*/
/*jshint browser: true*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Thu Jul 07 2016 11:24:16 GMT-0500 (Central Daylight Time).
 */

define(['js/Constants',
    'js/Utils/GMEConcepts',
    'js/NodePropertyNames'
], function (CONSTANTS,
    GMEConcepts,
    nodePropertyNames) {

        'use strict';

        var StatusControl;

        StatusControl = function (options) {

            this._logger = options.logger.fork('Control');

            this._client = options.client;

            // Initialize core collections and variables
            this._widget = options.widget;

            this._currentNodeId = null;
            this._currentNodeParentId = undefined;

            this._initWidgetEventHandlers();

            this._logger.debug('ctor finished');

            this.parentFoldersVisited = 0;
            this.parentFolders = [];
            this.type = '';
           
            this.exptTypes = [];
            this.alcid = '';
            this.countlimit =1;
        };

        StatusControl.prototype._initWidgetEventHandlers = function () {
            var self = this;
            this._widget.getnodeaddress = function (id) {
                
                    var address = window.location.origin + WebGMEGlobal.gmeConfig.client.mountedPath + '/?project=' + encodeURIComponent(self._client.getActiveProjectId());
                    address += '&branch=' + encodeURIComponent(self._client.getActiveBranchName());
                    var pos = id.lastIndexOf('/')
                    var parentid = id.substring(0,pos);
                    address += '&node='+ encodeURIComponent(parentid);
                    address +='&visualizer=ArtifactIndex';
                    //window.open(address, '_blank');
                    //window.focus();
                    
                    /*self._logger.debug('*******************got object');
                    if (targetNodeObj.getParentId() || targetNodeObj.getParentId() === CONSTANTS.PROJECT_ROOT_ID) {
                        self._logger.debug('*******************got parent id');
                        WebGMEGlobal.State.registerActiveObject(targetNodeObj.getParentId());
                        WebGMEGlobal.State.registerActiveSelection([id]);
                        WebGMEGlobal.State.registerActiveVisualizer('ModelEditor');
                    }*/

                //}
                return address;

            };
            this._widget.onNodeClick = function (id) {
                //var targetNodeObj = self._client.getNode(id);
                //if (targetNodeObj) {
                    var address = window.location.origin + WebGMEGlobal.gmeConfig.client.mountedPath + '/?project=' + encodeURIComponent(self._client.getActiveProjectId());
                    address += '&branch=' + encodeURIComponent(self._client.getActiveBranchName());
                    address += '&node='+ encodeURIComponent(id);
                    window.open(address, '_blank');
                    window.focus();
                    
                    /*self._logger.debug('*******************got object');
                    if (targetNodeObj.getParentId() || targetNodeObj.getParentId() === CONSTANTS.PROJECT_ROOT_ID) {
                        self._logger.debug('*******************got parent id');
                        WebGMEGlobal.State.registerActiveObject(targetNodeObj.getParentId());
                        WebGMEGlobal.State.registerActiveSelection([id]);
                        WebGMEGlobal.State.registerActiveVisualizer('ModelEditor');
                    }*/

                //}

            };


            this._widget.onEditSelectionInfo = function (value) {
                self._logger.debug(' on edit onEditNode1');
                
            };

            this._widget.onEditSetInfo = function (ids) {
                self._logger.debug(' on edit onEditNode1');
               
            };
        };

        /* * * * * * * * Visualizer content update callbacks * * * * * * * */
        // One major concept here is with managing the territory. The territory
        // defines the parts of the project that the visualizer is interested in
        // (this allows the browser to then only load those relevant parts).
        StatusControl.prototype.selectedObjectChanged = function (nodeId) {

            var desc = undefined,
                self = this;
            self._getObjectDescriptor(nodeId)
                .then(function (desc) {

                    self._logger.debug('activeObject nodeId \'' + nodeId + '\'');
                    self._logger.debug('metaname of activeobject= ' + desc.metaName);

                    // Remove current territory patterns
                    if (self._currentNodeId) {
                        self._client.removeUI(self._territoryId);
                    }

                    self._currentNodeId = nodeId;
                    self._currentNodeParentId = undefined;

                    if (typeof self._currentNodeId === 'string') {
                        // Put new node's info into territory rules
                        self._selfPatterns = {};
                        self._selfPatterns[nodeId] = { children: 2 };  // Territory "rule"

                        self._widget.setTitle("");

                        if (typeof desc.parentId === 'string') {
                            self.$btnModelHierarchyUp.show();
                        } else {
                            self.$btnModelHierarchyUp.hide();
                        }

                        self._currentNodeParentId = desc.parentId;

                        self._territoryId = self._client.addUI(self, function (events) {
                            self._eventCallback(events);
                        });

                        // Update the territory
                        //self._client.updateTerritory(self._territoryId, self._selfPatterns);

                        //self._selfPatterns[nodeId] = {children: 100};
                        //self._client.updateTerritory(self._territoryId, self._selfPatterns);

                        self._selfPatterns[nodeId] = { children: 2 };
                        
                        self._client.updateTerritory(self._territoryId, self._selfPatterns);
                    }
                });
        };

        // This next function retrieves the relevant node information for the widget
        StatusControl.prototype._getObjectDescriptor = function (nodeId) {
            var self = this;
            var nodeObj = self._client.getNode(nodeId);
            var obj, k;


            return new Promise(function (resolve, reject) {

                if (nodeObj) {
                    var objDescriptor = {
                        id: undefined,
                        metaName: undefined,
                        execName: undefined,
                        status: '',
                        info: {},
                        init: [],
                        use: 0,
                        last:0
                    };

                    var metaObj = self._client.getNode(nodeObj.getMetaTypeId()),
                        id = nodeObj.getId(),
                        metaName = '';

                    if (metaObj) {
                        metaName = metaObj.getAttribute(nodePropertyNames.Attributes.name);
                    }

                    
                    if (self._currentNodeId && (metaName=="WFExecStatus")) {
                        
                        objDescriptor.id = nodeObj.getId();
                        objDescriptor.metaName = metaName;
                        objDescriptor.execName = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
                        objDescriptor.status = nodeObj.getAttribute('CurStatus');;
                        objDescriptor.info = nodeObj.getAttribute('Info');
                        objDescriptor.init = nodeObj.getAttribute('Init');
                    }

                    

                    if (self._currentNodeId && (metaName=="WorkflowJob")) {
                        
                        objDescriptor.id = nodeObj.getId();
                        objDescriptor.metaName = metaName;
                        objDescriptor.execName = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
                    }

                    resolve(objDescriptor);

                }
            });
        };

        /* * * * * * * * Node Event Handling * * * * * * * */
        StatusControl.prototype._eventCallback = function (events) {
            var i = events ? events.length : 0,
                event;

            this._logger.debug('_eventCallback \'' + i + '\' items');
            

            while (i--) {
                event = events[i];
                switch (event.etype) {
                    case CONSTANTS.TERRITORY_EVENT_LOAD:
                        this._logger.debug('event '+i)
                        this._onLoad(event.eid, i);
                        this.countlimit = i;
                        break;
                    case CONSTANTS.TERRITORY_EVENT_UPDATE:
                        this._onUpdate(event.eid);
                        break;
                    case CONSTANTS.TERRITORY_EVENT_UNLOAD:
                        this._onUnload(event.eid);
                        break;
                    default:
                        break;
                }
            }

            this._logger.debug('event outside  '+i)

            

            this._logger.debug('_eventCallback \'' + events.length + '\' items - DONE');
        };

       

        StatusControl.prototype._onLoad = function (gmeId, count = -1) {
            var self = this;
            this._getObjectDescriptor(gmeId)
                .then(function (description) {
                    description.last = -1;
                    if (count == self.countlimit) {
                        
                        description.last = 1;
                        
                    }

                    if (description.metaName || (description.last==1))
                        self._widget.addNode(description);

                });

        };

        StatusControl.prototype._onUpdate = function (gmeId) {
            var self = this;
            self._getObjectDescriptor(gmeId)
                .then(function (description) {
                    self._logger.debug('metaname  _onUpdate= '+ description.metaName);
                    self._widget.updateNode(description);
                });
        };

        StatusControl.prototype._onUnload = function (gmeId) {
            this._widget.removeNode(gmeId);
        };

        StatusControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
            if (this._currentNodeId === activeObjectId) {
                // The same node selected as before - do not trigger
            } else {
                this.selectedObjectChanged(activeObjectId);
            }
        };

        /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
        StatusControl.prototype.destroy = function () {
            this._detachClientEventListeners();
            this._removeToolbarItems();
        };

        StatusControl.prototype._attachClientEventListeners = function () {
            this._detachClientEventListeners();
            WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
        };

        StatusControl.prototype._detachClientEventListeners = function () {
            WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
        };

        StatusControl.prototype.onActivate = function () {
            this._attachClientEventListeners();
            this._displayToolbarItems();

            if (typeof this._currentNodeId === 'string') {
                WebGMEGlobal.State.registerSuppressVisualizerFromNode(true);
                WebGMEGlobal.State.registerActiveObject(this._currentNodeId);
                WebGMEGlobal.State.registerSuppressVisualizerFromNode(false);
            }
        };

        StatusControl.prototype.onDeactivate = function () {
            this._detachClientEventListeners();
            this._hideToolbarItems();
        };

        /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
        StatusControl.prototype._displayToolbarItems = function () {

            if (this._toolbarInitialized === true) {
                for (var i = this._toolbarItems.length; i--;) {
                    this._toolbarItems[i].show();
                }
            } else {
                this._initializeToolbar();
            }
        };

        StatusControl.prototype._hideToolbarItems = function () {

            if (this._toolbarInitialized === true) {
                for (var i = this._toolbarItems.length; i--;) {
                    this._toolbarItems[i].hide();
                }
            }
        };

        StatusControl.prototype._removeToolbarItems = function () {

            if (this._toolbarInitialized === true) {
                for (var i = this._toolbarItems.length; i--;) {
                    this._toolbarItems[i].destroy();
                }
            }
        };

        StatusControl.prototype._initializeToolbar = function () {
            var self = this,
                toolBar = WebGMEGlobal.Toolbar;

            this._toolbarItems = [];

            this._toolbarItems.push(toolBar.addSeparator());

            /************** Go to hierarchical parent button ****************/
            this.$btnModelHierarchyUp = toolBar.addButton({
                title: 'Go to parent',
                icon: 'glyphicon glyphicon-circle-arrow-up',
                clickFn: function (/*data*/) {
                    WebGMEGlobal.State.registerActiveObject(self._currentNodeParentId);
                }
            });
            this._toolbarItems.push(this.$btnModelHierarchyUp);
            this.$btnModelHierarchyUp.hide();

            /************** Checkbox example *******************/

            this.$cbShowConnection = toolBar.addCheckBox({
                title: 'toggle checkbox',
                icon: 'gme icon-gme_diagonal-arrow',
                checkChangedFn: function (data, checked) {
                    self._logger.debug('Checkbox has been clicked!');
                }
            });
            this._toolbarItems.push(this.$cbShowConnection);

            this._toolbarInitialized = true;
        };

        return StatusControl;
    });
