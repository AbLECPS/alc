/*globals define*/

/**
 * Generated by RestRouterGenerator 2.2.0 from webgme on Fri Nov 13 2020 10:12:31 GMT-0600 (Central Standard Time).
 * To use in webgme add to gmeConfig.rest.components[SlurmRouter] = {
 *    mount: 'path/subPath',
 *    src: path.join(process.cwd(), './SlurmRouter'),
 *    options: {}
 * }
 * If you put this file in the root of your directory the above will expose the routes at
 * <host>/path/subPath, for example GET <host>/path/subPath/getExample will be routed to the getExample below.
 */

'use strict';

var unix_socket_file = "/tmp/slurm.sock"
var request_timeout = 10 // IN SECONDS

var post_method_string = "POST"

var slurm_version_string = "v0.0.35"

var headers_option_name = "headers",
    method_option_name = "method",
    path_option_name = "path",
    socket_path_option_name = "socketPath",
    timeout_option_name = "timeout"

var accept_header_name = "accept",
    content_type_header_name = "content-type",
    content_length_header_name = "content-length"

var accept_all_string = "*/*",
    json_content_type_string = "application/json",
    url_encoded_content_type_string = "application/x-www-form-urlencoded"


// http://expressjs.com/en/guide/routing.html
var express = require('express'),
    http = require('http'),
    uuid = require('uuid'),
    router = express.Router();

// SO ROUTER CAN PARSE RESPONSE CONTENT
router.use(express.json())
router.use(express.urlencoded({ extended: true }))


function process_request(req, res, logger, proxy_uuid) {

    try {

        // USER OF ROUTE SHOULDN'T HAVE TO KEEP UP WITH CURRENT VERSION OF slurmrestd
        var new_path = "/slurm/" + slurm_version_string + req.path;

        // logger.info(
        //     "(" + proxy_uuid + ") Slurm router accepted path \"" + req.path + "\", translated to path \"" + new_path +
        //     "\" for slurmrestd"
        // );

        // GET METHOD USED BY USER (UPPERCASE)
        var proxy_method = req.method.toUpperCase()

        //
        // MAKE (PROXY) REQUEST TO slurmrestd
        //

        // GET OPTIONS FOR REQUEST TO slurmrestd
        var request_options = {};
        // logger.info("(" + proxy_uuid + ") Request headers:\n" + JSON.stringify(req.headers, undefined, 4))
        var headers = {}
        headers[accept_header_name] = accept_all_string

        var lowercase_request_headers = {}
        Object.keys(req.headers).forEach(function (key, index) {
            lowercase_request_headers[key.toLowerCase()] = req.headers[key]
        })

        var content_type_string = url_encoded_content_type_string
        if (content_type_header_name in lowercase_request_headers) {
            content_type_string = lowercase_request_headers[content_type_header_name]
        }
        headers[content_type_header_name] = content_type_string

        var request_payload = ''
        if (proxy_method == post_method_string) {
            request_payload = JSON.stringify(req.body, undefined, 4)
            headers[content_length_header_name] = request_payload.length
        }

        request_options[headers_option_name] = headers;
        request_options[method_option_name] = proxy_method;
        request_options[path_option_name] = new_path;
        request_options[socket_path_option_name] = unix_socket_file;
        request_options[timeout_option_name] = request_timeout * 1000

        // logger.info(
        //     "(" + proxy_uuid + ") Options for http.request() to slurmrestd:\n" +
        //     JSON.stringify(request_options, undefined, 4)
        // );

        var proxy_request = http.request(request_options, function(proxy_response) {

            // logger.info("(" + proxy_uuid + ") Processing response from slurmrestd ... ")

            //
            // PROCESS RESPONSE FROM slurmrestd
            //

            // COLLECT POST DATA IF ANY
            var raw_data = ''
            proxy_response.on('data', function(chunk) {
                raw_data += chunk;
            });


            // ONCE ENTIRE PROXY RESPONSE COMES IN, PASS ON TO RESPONSE FOR THIS ROUTER
            proxy_response.on('end', function() {

                // logger.info("(" + proxy_uuid + ") Response from slurmrestd:");
                // logger.info("(" + proxy_uuid + ") slurmrestd status: " + proxy_response.statusCode);
                // logger.info("(" + proxy_uuid + ") slurmrestd status message: " + proxy_response.statusMessage);
                // logger.info(
                //     "(" + proxy_uuid + ") slurmrestd headers:" + JSON.stringify(proxy_response.headers, undefined, 4)
                // );
                // logger.info("(" + proxy_uuid + ") slurmrestd data:\n" + raw_data);

                // SET STATUS, STATUS MESSAGE, HEADERS FOR (ACTUAL) RESPONSE
                res.writeHead(proxy_response.statusCode, proxy_response.statusMessage, proxy_response.headers)
                // TRANSFER DATA FROM PROXY RESPONSE TO ACTUAL RESPONSE
                res.write(raw_data);
                // DONE
                res.end();
            });

            // logger.info("(" + proxy_uuid + ") End of slurmrestd response processing function.");
        });

        // PLACE POST DATA FROM ACTUAL REQUEST INTO BODY OF PROXY REQUEST
        if (proxy_method == post_method_string) {
            // logger.info("(" + proxy_uuid + ") Writing data to slurmrestd:\n" + request_payload);
            proxy_request.write(request_payload);
        }

        // BASIC ERROR PROCEESSING
        proxy_request.on('error', function(e) {
            logger.error("(" + proxy_uuid + ") problem with request: " + e.message)
        });

        // END OF PROXY REQUEST
        proxy_request.end();
        // logger.info("(" + proxy_uuid + ") End of request to slurmrestd");

    } catch(err) {
        logger.error("(" + proxy_uuid + ") ERROR: " + err.message);
    }
}

/**
 * Called when the server is created but before it starts to listening to incoming requests.
 * N.B. gmeAuth, safeStorage and workerManager are not ready to use until the start function is called.
 * (However inside an incoming request they are all ensured to have been initialized.)
 *
 * @param {object} middlewareOpts - Passed by the webgme server.
 * @param {GmeConfig} middlewareOpts.gmeConfig - GME config parameters.
 * @param {GmeLogger} middlewareOpts.logger - logger
 * @param {function} middlewareOpts.ensureAuthenticated - Ensures the user is authenticated.
 * @param {function} middlewareOpts.getUserId - If authenticated retrieves the userId from the request.
 * @param {object} middlewareOpts.gmeAuth - Authorization module.
 * @param {object} middlewareOpts.safeStorage - Accesses the storage and emits events (PROJECT_CREATED, COMMIT..).
 * @param {object} middlewareOpts.workerManager - Spawns and keeps track of "worker" sub-processes.
 */
function initialize(middlewareOpts) {
    var logger = middlewareOpts.logger.fork('SlurmRouter'),
        ensureAuthenticated = middlewareOpts.ensureAuthenticated,
        getUserId = middlewareOpts.getUserId;

    // logger.info('slurm router initializing ...');

    // Ensure authenticated can be used only after this rule.
    router.use('*', function (req, res, next) {
        // TODO: set all headers, check rate limit, etc.

        // This header ensures that any failures with authentication won't redirect.
        res.setHeader('X-WebGME-Media-Type', 'webgme.v1');
        next();
    });

    // Use ensureAuthenticated if the routes require authentication. (Can be set explicitly for each route.)
    router.use('*', ensureAuthenticated);

    // ROUTER FOR ALL PATHS STARTING WITH '/slurm/'
    router.all('*', function (req, res/*, next*/) {
        var proxy_uuid = uuid.v4();
        process_request(req, res, logger, proxy_uuid);
    });

}

/**
 * Called before the server starts listening.
 * @param {function} callback
 */
function start(callback) {
    callback();
}

/**
 * Called after the server stopped listening.
 * @param {function} callback
 */
function stop(callback) {
    callback();
}


module.exports = {
    initialize: initialize,
    router: router,
    start: start,
    stop: stop
};
