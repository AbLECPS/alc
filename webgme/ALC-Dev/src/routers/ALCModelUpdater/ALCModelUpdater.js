/*globals define*/

/**
 * Generated by RestRouterGenerator 2.2.0 from webgme on Mon Jan 11 2021 09:44:33 GMT-0600 (Central Standard Time).
 * To use in webgme add to gmeConfig.rest.components[ALCModelUpdater] = {
 *    mount: 'path/subPath',
 *    src: path.join(process.cwd(), './ALCModelUpdater'),
 *    options: {}
 * }
 * If you put this file in the root of your directory the above will expose the routes at
 * <host>/path/subPath, for example GET <host>/path/subPath/getExample will be routed to the getExample below.
 */

'use strict';

// http://expressjs.com/en/guide/routing.html
var express = require('express'),
    Inotify = require('inotify').Inotify,
    fs = require('fs'),
    uuid = require('uuid'),
    Q = require('q'),
    router = express.Router();


const webgme = require('webgme-engine/index');
const Core = webgme.requirejs('common/core/coreQ');
const merge = webgme.requirejs('common/core/users/merge')

let active_node_path_key = "active_node_path";
let conflict_function_key = "conflict_function";
let project_id_key = "projectId";
let use_lock_file_key = "use_lock_file";
let use_merge_key = "use_merge";

let lock_file_dir = "/tmp/alcmodelupdater";
//let lock_file_name = "DB_WIDE_LOCKFILE";
//let lock_file_path = lock_file_dir + "/" + lock_file_name;
let open_flags = fs.constants.O_WRONLY | fs.constants.O_CREAT | fs.constants.O_EXCL;
let lock_file_mode = 0o444;

let max_conflict_retries = 10;
let conflict_wait_time_ms = 10;

function sendDataResponse(context, success) {

    let response_payload_json = success ? {
        node_path: context.core.getPath(context.data_node)
    } : {
        success
    };
    let response_payload = JSON.stringify(response_payload_json, null, 4);
    let header = {
        "Content-Type": "application/json",
        "Content-Length": response_payload.length
    };

    context.res.writeHeader(200, header);
    context.res.write(response_payload);
    context.res.end();

    return null;
}


function sendDataUpdateResponse(context, success) {

    let response_payload_json = {
        success
    };
    let response_payload = JSON.stringify(response_payload_json, null, 4);
    let header = {
        "Content-Type": "application/json",
        "Content-Length": response_payload.length
    };

    context.res.writeHeader(200, header);
    context.res.write(response_payload);
    context.res.end();

    return null;
}


function getChildMetaNodePromise(context, base_node, end_pattern) {

    let base_node_meta = context.core.getMetaType(base_node);
    // let display_list = Object.entries(context.core.getChildrenMeta(base_node_meta));
    let base_node_meta_child_path_list =
        Object.entries(context.core.getChildrenMeta(base_node_meta)).map(x => x[0]).filter(x => x.startsWith("/"));
    let no_children = base_node_meta_child_path_list.length;

    let index = 0;
    function childMetaSearchLoop() {
        return Q.fcall(function() {
            if (index < no_children) {
                let child_meta_path = base_node_meta_child_path_list[index];
                index += 1;
                return context.core.loadByPath(context.root, child_meta_path);
            }
            return Q.reject(null);
        })
            .then(function(child_meta_node) {
                let child_meta_node_name = context.core.getFullyQualifiedName(child_meta_node);
                if (child_meta_node_name.endsWith(end_pattern)) {
                    return Q.reject(child_meta_node);
                }
                return Q.resolve();
            })
            .then(childMetaSearchLoop, x => Q.resolve(x));
    }

    return childMetaSearchLoop();
}

function getResultMetaNodePromise(context) {
    return getChildMetaNodePromise(context, context.active_node,".Result");
}

function getResultNode(context) {

    let active_node_child_path_list = context.core.getChildrenPaths(context.active_node);
    let no_children = active_node_child_path_list.length;

    let index = 0;
    function resultNodeSearchLoop() {
        return Q.fcall(function() {
            if (index < no_children) {
                let active_node_child_path = active_node_child_path_list[index];
                index += 1;
                return context.core.loadByPath(context.root, active_node_child_path);
            }
            return Q.reject(null);
        })
            .then(function(child_node) {
                let child_node_meta = context.core.getMetaType(child_node);
                let child_node_meta_name = context.core.getFullyQualifiedName(child_node_meta);
                if (child_node_meta_name === context.result_meta_name) {
                    return Q.reject(child_node);
                }
                return Q.resolve();
            })
            .then(resultNodeSearchLoop, x => Q.resolve(x));
    }

    return resultNodeSearchLoop();
}

// function hasResultNode(context) {
//     return getResultNode(context) != null;
// }
//
// function createResultNode(context) {
//
//     const result_node = context.core.createChild(context.active_node, context.result_meta_node);
//     context.core.setAttribute(result_node, "name", "Result");
//     return result_node;
// }

function shouldAppendNumber(name, data_node_name_list) {
    let appendNumber = false;
    for(const data_node_name of data_node_name_list) {
        if (data_node_name.startsWith(name)) {
            let remainder = data_node_name.substring(name.length);
            if (
                remainder === "" ||
                (remainder.length >= 2 && remainder.charAt(0) === '-' && /^\d+$/.test(remainder.charAt(1)))
            ) {
                appendNumber = true;
                break;
            }
        }
    }
    return appendNumber;
}

function performAppendNumber(name, data_node_name_list) {

    let new_name = null;
    let number = 0;
    let check_number = true;
    while(check_number) {
        check_number = false;
        new_name = name + "-" + number;
        for(const data_node_name of data_node_name_list) {
            if (data_node_name.startsWith(new_name)) {
                let remainder = data_node_name.substring(new_name.length);
                if (remainder === "" || remainder.startsWith("-")) {
                    check_number = true;
                    break;
                }
            }
        }
        number += 1;
    }
    return new_name;
}

function createDataNode(context) {

    let result_node_child_path_list = context.core.getChildrenPaths(context.result_node);
    let no_children = result_node_child_path_list.length;
    let data_meta_node = null;
    let data_meta_node_name = null;
    let data_node_name_list = [];
    let index = 0;
    let valindex = 0;
    let promises = [];
    let data_node = null;

    function dataNodeNameSearchLoop() {
        return Q.fcall(function() {
            if (index < no_children) {
                let result_node_child_path = result_node_child_path_list[index];
                index += 1;
                return context.core.loadByPath(context.root, result_node_child_path);
            }
            return Q.reject();
        })
            .then(function(child_node) {
                let child_node_meta = context.core.getMetaType(child_node);
                let child_node_meta_name = context.core.getFullyQualifiedName(child_node_meta);
                if (child_node_meta_name === data_meta_node_name) {
                    data_node_name_list.push(context.core.getFullyQualifiedName(child_node));
                }
                return Q.resolve();
            })
            .then(dataNodeNameSearchLoop, Q.resolve);
    }

    return getChildMetaNodePromise(context, context.result_node, ".pipeline.Data")
        .then(data_meta_node_param => {
            data_meta_node = data_meta_node_param;
            data_meta_node_name = context.core.getFullyQualifiedName(data_meta_node);
            return Q.resolve();
        })
        .then(dataNodeNameSearchLoop)
        .then(() => {
            let name = context.req.body.name;
            return shouldAppendNumber(name, data_node_name_list) ?
                performAppendNumber(name, data_node_name_list) : name;
        })
        .then(name => {
            data_node = context.core.createChild(context.result_node, data_meta_node);
            context.core.setAttribute(data_node, "name", name);
            context.core.setAttribute(data_node, "activity", context.core.getFullyQualifiedName(context.active_node));
            context.core.setAttribute(data_node, "createdAt", new Date().getTime());
            let attribute_set = new Set(context.core.getAttributeNames(data_node));
            let body = context.req.body;

            if (body.hasOwnProperty("modifications")) {
                let modifications = body.modifications;
                context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": modifications ");
                for (const [key, value] of Object.entries(modifications)) {
                    context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": modifications " + key);
                    if (attribute_set.has(key)) {
                        context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": modifications " + value);
                        context.core.setAttribute(data_node, key, value);
                    }
                }
            }

            if (body.hasOwnProperty("sets")) {
                let set_data = body.sets;
                context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": sets ");
                if (Object.keys(set_data).length) {

                    for (const [key, value] of Object.entries(set_data)) {
                        context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": sets " + key);
                        if (value && value.length) {
                            promises.push(Q.all(value.map(nId => context.core.loadByPath(context.root, nId)))
                                .then(result_contents => {
                                    for (valindex = 0; valindex != result_contents.length; valindex += 1) {
                                        context.core.addMember(data_node, key, result_contents[valindex]);
                                    }
                                }));
                        }
                    }
                }
            }
            return Q.all(promises);
        })
        .then(() => {
            return data_node;
        });

}

function createJupyterNode(context) {

    let data_meta_node = null;
    return getChildMetaNodePromise(context, context.active_node, ".Notebook")
        .then(data_meta_node_param => {
            if (data_meta_node_param){
                context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": got meta node" );
            }
            else {
                context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": no meta node" );
            }
            data_meta_node = data_meta_node_param;
            if (context.active_node){
                context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": got active node" );
            }
            else {
                context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": no active node" );
            }
            const data_node = context.core.createChild(context.active_node, data_meta_node);
            let name = context.req.body.name;
            let url = context.req.body.url;
            let position = context.req.body.position;

            context.core.setAttribute(data_node, "name", name);
            context.core.setAttribute(data_node, "url", url);
            context.core.setRegistry(data_node, 'position', position)
            
            return data_node;
        });
}

function getActiveNode(userId, safeStorage, context) {

    // RETURN PROJECT
    return safeStorage.getProjects({username: userId})
        // Checking if the project in question is valid
        .then(result => {

            // result is an array where every element has projectId, owner, and projectName fields
            let found = false;
            result.forEach(project => {
                if (project._id === context.req.body.projectId) {
                    found = true;
                }
            });
            if (!found) {
                throw new Error('Unknown project...');
            }

            return safeStorage.openProject({
                username: userId,
                projectId: context.req.body.projectId
            });
        })
        // RETURN THE PROJECT BRANCHES
        .then(userProject => {
            userProject.setUser(userId);

            context.project = userProject;
            context.core = new Core(userProject, {
                globConf: context.config,
                logger: context.logger.fork('core')
            });

            return userProject.getBranches();
        })
        // GET COMMIT OBJECT
        .then((/*branches*/) => {
            // this is optional if we know the name of the branch, or if it is an input
            // the branches will be a name - commitHash collection so all branches can be opened
            context.branchName = 'master';

            return context.project.getCommitObject(context.branchName);
        })
        // GET PROJECT ROOT
        .then(commitObject => {
            //the commit object contains all important hashes
            context.commitObject = commitObject;

            return context.core.loadRoot(commitObject.root);
        // GET ACTIVE NODE
        }).then(root => {
            // now that we loaded the root node, any update can happen
            context.root = root;

            let body = context.req.body;
            context.active_node_path = body[active_node_path_key];

            return context.core.loadByPath(context.root, context.active_node_path);
        });
}

function mergeCommit(context, result) {
    context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  performing merge");

    let finalCommitHash = null;
    let attemptNumber = 0;

    function mergeIteration(myHash) {
        return Q.fcall(function() {
            ++attemptNumber;
            context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  merge attempt " + attemptNumber);

            return merge.merge({
                project: context.project,
                logger: context.logger,
                gmeConfig: context.config,
                myBranchOrCommit: myHash,
                theirBranchOrCommit: context.branchName, // 'master'
                // branchName: context.branchName,
                auto: true
            });
        })
        .then(mergeResult => {
            // SINCE A UNIQUE CHILD NODE WAS CREATED, NOT EXPECTING ANY CONFLICTS
            if (!mergeResult.conflict || mergeResult.conflict.items.length === 0) {
                return mergeResult;
            }

            context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  detected conflict(s)");
            if (context.hasOwnProperty(conflict_function_key)) {
                context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  resolving conflict(s)");
                mergeResult.conflict.items = mergeResult.conflict.items.map(item => {
                    return context[conflict_function_key](context, item);
                });
                // resolve
                return merge.resolve({
                    partial: mergeResult,
                    project: context.project,
                    logger: context.logger,
                    gmeConfig: context.config,
                    myBranchOrCommit: myHash,
                    theirBranchOrCommit: context.branchName, // 'master'
                    // branchName: context.branchName,
                    auto: true
                });
            }

            context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  no means of resolving conflict(s)");
            let num_conflicts = mergeResult.conflict.items.length;
            throw new Error("(" + context.proxy_uuid + ") " + context.function_name + ":  Problem with merge: " + num_conflicts + " detected.");
        })
        .then(mergeResult => {
            // for(const property in mergeResult) {
            //     context.logger.info("conflict mergeResult[\"" + property + "\"] = \"" + mergeResult[property] + "\"");
            // }
            // for(const property in mergeResult.conflict) {
            //     context.logger.info("conflict mergeResult.conflict[\"" + property + "\"] = \"" + mergeResult.conflict[property] + "\"");
            // }
            finalCommitHash = mergeResult.hasOwnProperty("finalCommitHash") ? mergeResult.finalCommitHash : mergeResult.hash;
            return context.project.getBranches();
        })
        .then(getBranchesResult => {
            let actualCommitHash = getBranchesResult["master"];

            if (finalCommitHash === actualCommitHash) {
                context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": " + context.success_message);
                return context.success_function();
            }

            return mergeIteration(finalCommitHash);
        });
    }

    return mergeIteration(result.hash);
}

function commitWithMerge(context) {

    let conflict_should_retry = false;

    return Q.fcall(function() {
        context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  performing commit");
        const persisted = context.core.persist(context.root);

        return context.project.makeCommit(
            context.branchName,
            [context.commitObject._id],
            persisted.rootHash,
            persisted.objects,
            "example update finished - " + context.function_name
        );
    })
    .then(result => {
        // We expect a SYNCED result, otherwise we either forked or something bad happened.
        // example result: { status: 'SYNCED', hash: '#fd692cc9ac18153149e9c53906cad13017aaebae' }
        if (result.status === 'SYNCED') {
            context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": " + context.success_message);
            return context.success_function();
        }

        if (!context.use_merge) {
            conflict_should_retry = true;
            if (conflict_retry_no >= max_conflict_retries) {
                throw new Error("cannot update project");
            } else {
                return null;
            }
        }

        return result;
    })
    .then(result => {
        if (result !== null) {
            context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ":  MERGING ...")
            return mergeCommit(context, result);
        } else {
            context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ":  NO MERGE")
        }
    })
    .catch(error => {
        logger.error("(" + context.proxy_uuid + ") " + context.function_name + ": " + error);
        return context.failure_function();
    })
    .finally(() => {
        if (context.use_lock_file) {
            context.logger.info(
                "(" + context.proxy_uuid + ") " + context.function_name + ": Removing lock file \"" + context.lock_file_path + "\""
            );
            fs.unlinkSync(context.lock_file_path);
        } else {
            context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ": Not using lock file so nothing to remove.")
        }

        if (conflict_should_retry) {
            if (context.conflict_retry_no < max_conflict_retries) {
                ++context.conflict_retry_no;
                context.logger.warn(
                    "(" + context.proxy_uuid + ") " + context.function_name + ": Conflict detected, retry " + context.conflict_retry_no +
                    " of " + max_conflict_retries + ".  Waiting " + conflict_wait_time_ms + " ms ..."
                );
                setTimeout(
                    () => context.router_function(context.req, context.res, context.proxy_uuid, context.conflict_retry_no),
                    conflict_wait_time_ms
                );
            } else {
                context.logger.warn(
                    "(" + context.proxy_uuid + ") " + context.function_name + ": Conflict detected.  Maximum retries (" + max_conflict_retries +
                    ") exceeded.  Giving up ..."
                );
                context.failure_function();
            }
        }
    });
}


function waitForLockFile(context) {
    context.logger.info(
        "(" + context.proxy_uuid + ") " + context.function_name + ":  Attempting to acquire lock file \"" + context.lock_file_path + "\""
    );
    let fd = 0;
    try {
        fd = fs.openSync(context.lock_file_path, open_flags, lock_file_mode);
    } catch(err) {
        fd = -1;
    }
    while (fd < 0) {
        context.logger.info(
            "(" + context.proxy_uuid + ") " + context.function_name + ":  Lock file \"" + context.lock_file_path +
            "\" exists, waiting for it to be removed ..."
        );
        let delete_notify = new Inotify();

        let lock_file = {
            path: context.lock_file_path,
            watch_for: Inotify.IN_DELETE_SELF,
            callback: function(event) {
                if (event.mask === Inotify.IN_DELETE_SELF) {
                    context.logger.info(
                        "(" + context.proxy_uuid + ") " + context.function_name + ":  Lock file \"" + context.lock_file_path + "\" removed."
                    );
                    delete_notify.close();
                    context.router_function(context.req, context.res, context.proxy_uuid, 0);
                }
            }
        };

        if (delete_notify.addWatch(lock_file) >= 0) {
            return false;
        }
        delete_notify.close();

        context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  Lock file \"" + context.lock_file_path + "\" removed.");
        context.logger.info(
            "(" + context.proxy_uuid + ") " + context.function_name + ": Attempting to acquire lock file \"" + context.lock_file_path + "\""
        );
        fd = fs.openSync(context.lock_file_path, open_flags, lock_file_mode);
    }
    context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  Lock file \"" + context.lock_file_path + "\" acquired.");
    fs.closeSync(fd);

    return true;
}


function getContext(req, res, logger, config, proxy_uuid, conflict_retry_no, function_name, router_function) {

    let project_id = req.body[project_id_key];
    let use_lock_file = req.body.hasOwnProperty(use_lock_file_key) ? req.body[use_lock_file_key] : true;
    let use_merge = req.body.hasOwnProperty(use_merge_key) ? req.body[use_merge_key] : false;

    return {
        req,
        res,
        logger,
        config,
        proxy_uuid,
        conflict_retry_no,
        function_name,
        router_function,
        use_lock_file,
        use_merge,
        lock_file_path: lock_file_dir + "/" + project_id
    }
}
/**
 * Called when the server is created but before it starts to listening to incoming requests.
 * N.B. gmeAuth, safeStorage and workerManager are not ready to use until the start function is called.
 * (However inside an incoming request they are all ensured to have been initialized.)
 *
 * @param {object} middlewareOpts - Passed by the webgme server.
 * @param {GmeConfig} middlewareOpts.gmeConfig - GME config parameters.
 * @param {GmeLogger} middlewareOpts.logger - logger
 * @param {function} middlewareOpts.ensureAuthenticated - Ensures the user is authenticated.
 * @param {function} middlewareOpts.getUserId - If authenticated retrieves the userId from the request.
 * @param {object} middlewareOpts.gmeAuth - Authorization module.
 * @param {object} middlewareOpts.safeStorage - Accesses the storage and emits events (PROJECT_CREATED, COMMIT..).
 * @param {object} middlewareOpts.workerManager - Spawns and keeps track of "worker" sub-processes.
 */
function initialize(middlewareOpts) {
    let logger = middlewareOpts.logger.fork('ALCModelUpdater'),
        ensureAuthenticated = middlewareOpts.ensureAuthenticated,
        getUserId = middlewareOpts.getUserId,
        config = middlewareOpts.gmeConfig,
        gmeAuth = middlewareOpts.gmeAuth,
        safeStorage = middlewareOpts.safeStorage;

    config.storage.autoMerge.enable = true;

    logger.debug('initializing ...');

    // Ensure authenticated can be used only after this rule.
    router.use('*', function (req, res, next) {
        // TODO: set all headers, check rate limit, etc.

        // This header ensures that any failures with authentication won't redirect.
        res.setHeader('X-WebGME-Media-Type', 'webgme.v1');
        next();
    });

    // Use ensureAuthenticated if the routes require authentication. (Can be set explicitly for each route.)
    router.use('*', ensureAuthenticated);

    function createDataNodeRouter(req, res, proxy_uuid, conflict_retry_no) {

        // the complete object that will contain all necessary info to start manipulating the project
        let context = getContext(req, res, logger, config, proxy_uuid, conflict_retry_no, "createdatanode", createDataNodeRouter);

        if (context.use_lock_file) {
            if (!waitForLockFile(context)) {
                return;
            }
        } else {
            context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  Not using lock file.");
        }

        // Checking if the project in question is valid
        // RETURN PROJECT
        const userId = getUserId(req);
        getActiveNode(userId, safeStorage, context)
        // GET RESULT META NODE, CHILD OF ACTIVE NODE META NODE
            .then(active_node => {
                context.active_node = active_node;

                return getResultMetaNodePromise(context);
            })
            .then(result_meta_node => {
                context.result_meta_node = result_meta_node;
                context.result_meta_name = context.core.getFullyQualifiedName(context.result_meta_node);

                return getResultNode(context);
                // GET RESULT NODE
            })
            .then(result_node => {
                context.result_node = result_node;

                return createDataNode(context);
                // COMMIT THE NEW RESULT NODE TO THE MASTER BRANCH
            })
            .then(data_node => {
                // we will use the same context to create a commit and update the branch
                context.data_node = data_node;

                let data_node_path = context.core.getPath(context.data_node);
                context.logger.info(
                    "(" + context.proxy_uuid + ") " + context.function_name + ":  created data node of path \"" + data_node_path + "\""
                );

                context.success_message = "successful creation";
                context.success_function = function() { 
                    return sendDataResponse(context, true);
                }
                context.failure_function = function() {
                    return sendDataResponse(context, false);
                }
            })
            .then(() => commitWithMerge(context));
    }

    router.all('/createdatanode', function (req, res/*, next*/) {
        config.storage.autoMerge.enable = true;

        let proxy_uuid = uuid.v4();
        return createDataNodeRouter(req, res, proxy_uuid, 0);
    });

    function updateDataNodeRouter(req, res, proxy_uuid, conflict_retry_no) {

        // the complete object that will contain all necessary info to start manipulating the project
        let context = getContext(req, res, logger, config, proxy_uuid, conflict_retry_no, "updatedatanode", updateDataNodeRouter);

        if (context.use_lock_file) {
            if (!waitForLockFile(context)) {
                return;
            }
        } else {
            context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  Not using lock file.");
        }

        // Checking if the project in question is valid
        // RETURN PROJECT
        const userId = getUserId(req);
        getActiveNode(userId, safeStorage, context)
            .then(active_node => {

                context.active_node = active_node;

                let attribute_set = new Set(context.core.getAttributeNames(context.active_node));
                let body = context.req.body;
                let modifications = body.modifications;
                for (const [key, value] of Object.entries(modifications)) {
                    if (attribute_set.has(key)) {
                        context.logger.warn("(" + context.proxy_uuid + ") " + context.function_name + ": modification: " + key + " = \"" + value + "\"");
                        context.core.setAttribute(context.active_node, key, value);
                    } else {
                        context.logger.warn(
                            "(" + context.proxy_uuid + ") " + context.function_name + ": Invalid attribute detected: " + key
                        );
                    }
                }

                context.logger.info(
                    "(" + context.proxy_uuid + ") " + context.function_name + ":  updated data node of path \"" +
                    context.core.getPath(context.active_node) + "\""
                );

                context.success_message = "successful data node attribute update";
                context.success_function = function() { 
                    return sendDataUpdateResponse(context, true);
                }
                context.failure_function = function() {
                    return sendDataUpdateResponse(context, false);
                }
            })
            .then(() => commitWithMerge(context));
    }

    router.all('/updatedatanode', function (req, res/*, next*/) {
        config.storage.autoMerge.enable = true;

        let proxy_uuid = uuid.v4();
        return updateDataNodeRouter(req, res, proxy_uuid, 0);
    });

    function combineStatuses(context, status1, status2) {
        let status1_line_array = status1.trim().split("\n");
        let status1_size = status1_line_array.length

        let status2_line_array = status2.trim().split("\n");
        let status2_size = status2_line_array.length

        let new_line_array = [];

        let status1_index = 0;
        let status2_index = 0;

        let status1_value = status1_line_array[status1_index];
        let status2_value = status2_line_array[status2_index];

        while(status1_value === status2_value) {
            new_line_array.push(status1_value);
            ++status1_index;
            ++status2_index;
            if (status1_index >= status1_size || status2_index >= status2.size) {
                break;
            }
            status1_value = status1_line_array[status1_index];
            status2_value = status2_line_array[status2_index];
        }

        while(status1_index < status1_size) {
            new_line_array.push(status1_line_array[status1_index++]);
        }
        while(status2_index < status2_size) {
            new_line_array.push(status2_line_array[status2_index++]);
        }

        let new_value = new_line_array.join("\n") + "\n";
        return new_value;
    }

    function resolveStatusConflict(context, conflict_item) {
        if(conflict_item.mine.path.indexOf('/attr/') !== -1) {
            if(conflict_item.mine.value !== '*to*delete*' && conflict_item.theirs.value !== '*to*delete*') {
                //it is an attribute conflict and purely because the two branches set different values
                conflict_item.selected = 'other'; // we need to change this so the resolution will overwrite the original value
                conflict_item.other.value = combineStatuses(context, conflict_item.theirs.value, conflict_item.mine.value);
            }
        }
        return conflict_item;
    }

    function updateWorkflowStatusRouter(req, res, proxy_uuid, conflict_retry_no) {

        // the complete object that will contain all necessary info to start manipulating the project
        let context = getContext(req, res, logger, config, proxy_uuid, conflict_retry_no, "updatestatus", updateWorkflowStatusRouter);

        if (context.use_lock_file) {
            if (!waitForLockFile(context)) {
                return;
            }
        } else {
            context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  Not using lock file.");
        }

        // Checking if the project in question is valid
        // RETURN PROJECT
        const userId = getUserId(req);
        getActiveNode(userId, safeStorage, context)
            .then(active_node => {

                context.active_node = active_node;

                let current_status = context.core.getAttribute(context.active_node, "CurStatus");
                context.core.setAttribute(
                    context.active_node, "CurStatus", current_status + context.req.body.message + "\n"
                );

                context.success_message = "successful status update";
                context.success_function = function() { 
                    return sendDataUpdateResponse(context, true);
                }
                context.failure_function = function() {
                    return sendDataUpdateResponse(context, false);
                }
                context[conflict_function_key] = resolveStatusConflict
            })
            .then(() => commitWithMerge(context))
    }

    router.all('/updatestatus', function(req, res /*, next*/) {
        config.storage.autoMerge.enable = true;

        let proxy_uuid = uuid.v4();
        return updateWorkflowStatusRouter(req, res, proxy_uuid, 0);
    });

    function createJupyterNodeRouter(req, res, proxy_uuid, conflict_retry_no) {

        // the complete object that will contain all necessary info to start manipulating the project
        let context = getContext(req, res, logger, config, proxy_uuid, conflict_retry_no, "createjupyternode", createJupyterNodeRouter);

        if (context.use_lock_file) {
            if (!waitForLockFile(context)) {
                return;
            }
        } else {
            context.logger.info("(" + context.proxy_uuid + ") " + context.function_name + ":  Not using lock file.");
        }

        // Checking if the project in question is valid
        // RETURN PROJECT
        const userId = getUserId(req);
        getActiveNode(userId, safeStorage, context)
        // GET RESULT META NODE, CHILD OF ACTIVE NODE META NODE
            .then(active_node => {
                context.active_node = active_node;
                return createJupyterNode(context);
                // COMMIT THE NEW RESULT NODE TO THE MASTER BRANCH
            })
            .then(data_node => {
                // we will use the same context to create a commit and update the branch
                context.data_node = data_node;

                let data_node_path = context.core.getPath(context.data_node);
                context.logger.info(
                    "(" + context.proxy_uuid + ") " + context.function_name + ":  created jupyter node of path \"" + data_node_path + "\""
                );

                context.success_message = "jupyter node created";
                context.success_function = function() { 
                    return sendDataUpdateResponse(context, true);
                }
                context.failure_function = function() {
                    return sendDataUpdateResponse(context, false);
                }
            })
            .then(() => commitWithMerge(context))
    }

    router.all('/createjupyternode', function (req, res/*, next*/) {
        config.storage.autoMerge.enable = true;

        let proxy_uuid = uuid.v4();
        return createJupyterNodeRouter(req, res, proxy_uuid, 0);
    });

}

/**
 * Called before the server starts listening.
 * @param {function} callback
 */
function start(callback) {
    if (!fs.existsSync(lock_file_dir)) {
        fs.mkdirSync(lock_file_dir,  0o755);
    }
    callback();
}

/**
 * Called after the server stopped listening.
 * @param {function} callback
 */
function stop(callback) {
    callback();
}


module.exports = {
    initialize: initialize,
    router: router,
    start: start,
    stop: stop
};
