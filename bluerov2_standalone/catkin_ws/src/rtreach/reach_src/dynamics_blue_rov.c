#include "dynamics_uuv.h"
#include "dynamics_uuv_model.h"
#include "util.h"
#include "interval.h"

#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <math.h>

#ifdef DYNAMICS_UUV_MODEL

// Dynamical model for the UUV. The model was obtained using black box system identification techniques 
// With three states and two inputs. We neglect the depth of the uuv and assume it to be constant
// The form of the equations are

// X' = AX + BU

// X = [x;y;yaw] where x and y are the euclidean position, and yaw is the vehicle's orientation 
// U = [Heading, speed] where heading (degrees) and speed (m/s) are the set points for the  


// declare the matrices here to ease the replacement of new sys ID models

/*double A[3][3] = {{0.00498927278159024,-0.00223672221562356,-0.131047698498735},
                {0.000866141129732425,6.7779557341639e-05,0.280866352009697},
                {0.00251047916870906,-0.00152482013755708,-0.0550211458590531}};

double B[3][2] = {{-1.89259628544288e-05,0.290680599964534},
               {0.000119754962817709,0.127311458346654},
               {-0.00120277796056619,0.204292185523768}};*/


// double A[3][3] = {{-0.0167278303861544,-0.00565828993837386,-0.122129067035888},
//                 {0.0167004068426322,0.0091153558372474,0.0645991882008384},
//                 {0.00203452407225429,0.00135414624884792,-0.00412861249611667}};

// double B[3][2] = {{-0.00163654561701182,-0.0508060539566901},
//                {-0.00103537479208736,0.367906193240552},
//                {0.000133787496196076,-0.0289357049411593}};


// Lot's of left and right turns
// double A[3][3] = {{0.0069518720835482,0.00361931449228493,-0.0762782646582126},
//                  {-0.00374107330447563,0.000176121353117757,0.161889126117447},
//                  {0.000284159441507434,-0.000214947626116718,-0.000129934787970294}};

// double B[3][2] = {{0.000877567835782193,-0.11529876360127},
//                  {-7.8676692336172e-05,0.127455725140915},
//                  {0.000448125916178464,0.0119003518270372}};

// Only right turns
// double A[3][3] = {{-0.00363012026516691,0.131979793773412,0.517462596814948},
//                  {0.00287145726043239,-0.0450573466690846,-0.053199524034351},
//                  {-0.00730513372134982,0.0129247563313467,-0.0150892465225363}};

// double B[3][2] = {{0.0044627843404254,-0.441869909156022},
//                  {0.00300592196595029,0.433678593624553},
//                  {-0.000632557355797999,0.000894102701560755}};

// Waypoint Data
// double A[3][3] = {{0.00334033867410061,-0.0483039370200033,-0.790622557801644},
//                  {0.00396351827764204,0.0113698999713713,0.44061525627452},
//                  {-0.000921983392391404,0.00070025797979296,0.00396716276801456}};

// double B[3][2] = {{-0.00451383064417,1.19094722719037},
//                  {0.00729594303953539,0.00591299945812222},
//                  {-0.00649994710385847,-0.00258420462816076}};

// sys_iddata21
// double A[3][3] = {{-0.00421167102617794,-0.00301720535379085,0.783448633134333},
//                  {0.00175568430130159,0.00177921888450345,-0.0506277147471689},
//                  {-0.000100228070757194,4.98287895196525e-07,0.00470621154542978}};

// double B[3][2] = {{-0.00300792557116992,0.419543006372656},
//                  {0.00129878657446352,0.194755759781748},
//                  {0.00287515318390078,0.00205699015855779}};


// sys_iddata 18, 19, 21
// double A[3][3] = {{0.00777898015189168,-0.0126562142071081,-0.340094026007605},
//                  {-0.000874340425188845,0.0274034079131014,0.25985836744653},
//                  {0.00617739285775881,-0.0152308822676293,-0.040629776540377}};

// double B[3][2] = {{0.00591869874145635,0.716645591267839},
//                  {0.00160593990953629,-0.134224265294125},
//                  {0.000326246088390391,0.0109271159639772}};


// all the data
// double A[3][3] = {{0.00497906419091112,0.00103578200978835,0.0438019501676895},
//                  {0.000916189825623771,0.00214447838277821,0.153285317122596},
//                  {-0.000691321769369001,-0.000438334863473348,-0.0182665481623593}};

// double B[3][2] = {{0.000367891788104048,-0.111227300125435},
//                  {0.000563864410523177,0.144268583901599},
//                  {-0.00021091664564113,0.0339276471280937}};

// selected turns 18, 19, 21, 24, 25, 26
// double A[3][3] = {{0.000940705740603736,-0.000539681344992229,0.180128535023203},
//                  {9.14400777418702e-05,0.00187567801069296,0.153629056910518},
//                  {0.000472719318546447,0.000150906434023217,-0.016393510504002}};

// double B[3][2] = {{0.00369783205168538,0.319378716016737},
//                  {0.00229777520481123,0.157121610715732},
//                  {-9.65846061901187e-06,-0.0144455516510259}};

// selected turns 18 (had obstacles), 21, 25, 26
// double A[3][3] = {{-0.000172316418292891,-0.000430905936022108,-0.539085312312504},
//                  {-0.000456662281846551,-3.1020216928023e-05,0.53508618618827},
//                  {6.57089800400097e-05,-3.89250867262764e-05,0.0101816804118367}};

// double B[3][2] = {{-0.0029578850308368,0.999526482185694},
//                  {-0.00152587701254665,0.0226403392596314},
//                  {-0.00479157489175723,-0.0053926205502244}};


// no obstacles 

double A[3][3] = {{0.00561191683950008,-0.0355281567618792,-0.033963391721373},
                 {0.00225798435860513,0.0100972701325497,0.208101681377646},
                 {0.00016207734834874,-0.00512501667834739,-0.0382471366071198}};

double B[3][2] = {{-0.00465988438513523,0.816497511315634},
                 {0.00637539064907457,-0.0115884524590324},
                 {-0.00515952744808663,0.105742857187591}};

// implement the derivative using interval arithmetic
double get_derivative_bounds_uuv(HyperRectangle* rect, int faceIndex,REAL heading, REAL speed)
{
    int dim = faceIndex / 2;
	bool isMin = (faceIndex % 2) == 0;

    // Interval rv.min = rv.max =0
    Interval rv = new_interval_v(0);

    Interval x = rect->dims[0];
    Interval y = rect->dims[1];
    Interval yaw = rect->dims[2];
    Interval uh = new_interval_v(heading);
    Interval uv = new_interval_v(speed);

    
    
    Interval a1,a2,a3,b1,b2; // declare intervals for contants



    if( dim == 0 ) 
    {
        a1 = mul_interval(new_interval_v(A[0][0]),x);
        a2 = mul_interval(new_interval_v(A[0][1]),y);
        a3 = mul_interval(new_interval_v(A[0][2]),yaw);
        b1 = mul_interval(new_interval_v(B[0][0]),uh);
        b2 = mul_interval(new_interval_v(B[0][1]),uv);
        rv = add_interval(add_interval(add_interval(add_interval(a1,a2),a3),b1),b2);
    }
    else if(dim == 1)
    {
        a1 = mul_interval(new_interval_v(A[1][0]),x);
        a2 = mul_interval(new_interval_v(A[1][1]),y);
        a3 = mul_interval(new_interval_v(A[1][2]),yaw);
        b1 = mul_interval(new_interval_v(B[1][0]),uh);
        b2 = mul_interval(new_interval_v(B[1][1]),uv);
        rv = add_interval(add_interval(add_interval(add_interval(a1,a2),a3),b1),b2);
    }
    else if(dim ==2)
    {
        a1 = mul_interval(new_interval_v(A[2][0]),x);
        a2 = mul_interval(new_interval_v(A[2][1]),y);
        a3 = mul_interval(new_interval_v(A[2][2]),yaw);
        b1 = mul_interval(new_interval_v(B[2][0]),uh);
        b2 = mul_interval(new_interval_v(B[2][1]),uv);
        rv = add_interval(add_interval(add_interval(add_interval(a1,a2),a3),b1),b2);
    }
    else 
    {
        printf("Error: Invalid Dimension");
        exit(0);
    }

    return isMin ? rv.min : rv.max;

}
#endif